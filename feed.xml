<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="jjginga.com/feed.xml" rel="self" type="application/atom+xml"/><link href="jjginga.com/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-03-04T23:00:24+00:00</updated><id>jjginga.com/feed.xml</id><title type="html">blank</title><subtitle>Code whisperer by day, bug hunter by night, crafting digital magic with a sprinkle of caffeine and a dash of humor. </subtitle><entry><title type="html">what is a transaction</title><link href="jjginga.com/blog/2024/what_is_a_transaction/" rel="alternate" type="text/html" title="what is a transaction"/><published>2024-03-01T00:00:00+00:00</published><updated>2024-03-01T00:00:00+00:00</updated><id>jjginga.com/blog/2024/what_is_a_transaction</id><content type="html" xml:base="jjginga.com/blog/2024/what_is_a_transaction/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>Imagine you want to transfer money from one bank account to another. To do this there are several steps involve: withdrawing the amount from the first account, depositing the money in the second account. Since money unfortunately doesn’t grow in transactions, both of these operations must be completed successfully, if the withdrawn isn’t made the deposit can’t be done other, the amount deposited must be the same has the amount withdrawn. If it is not possible to complete the deposit the money must return to the account where it was withdrawn from. So these operations must be treated as a single operation or has we can say a single <strong>unit of work</strong>.</p> <p>From banking to baking, now let’s imagine we want to bake chocolate chip cookies, there is a set of actions you have to perform, like, getting all the ingredients, mixing them together, molding the cookies, putting them in the oven and baking them. While you are doing this your mother is also in the kitchen baking a cake. If she were to come and mix some some ingredients of the cake in the mixing bowl while you are preparing your dough, then it would become too runny or too dry. Or imagine the disappointment on your face tasting some bland hard bread because your mother accidentally used the sugar out of your ingredients. So, these operations must be performed with some level of <strong>isolation</strong> to ensure each task’s integrity and success.</p> <p>In both scenarios, the concept of <strong>“transaction”</strong> comes into play. A transaction, in its essence, is a sequence of operations or actions that are treated as a single unit of work. These operations must either all succeed together or fail together, ensuring <strong>data integrity and consistency</strong>. This concept is pivotal in various domains, including database management and software development.</p> <hr/> <h2 id="understanding-transactions">Understanding transactions</h2> <p>We use databases to store information, but, for this information to keep it’s usefulness it must be accessed and modified from time to time. To maintain the <strong>consistency and integrity</strong> of the data present this tasks should be performed systematically with a specific set of rules. In Database Management Systems this is called a <strong>transaction</strong>.</p> <p>Before diving deeper into transactions, let’s first clarify what we mean by <strong>consistency and integrity</strong>, as these are foundational to understanding the role and importance of transactions in database management.</p> <h1 id="consistency-and-integrity">Consistency and Integrity</h1> <p><strong>Consistency</strong> refers to the requirement that any transaction should bring the database from one valid state to another, ensuring that all data follows all rules and constraints (e.g., data types, triggers, constraints) of the database. For instance, in our cookie-baking analogy, consistency would be akin to following a recipe precisely. Just as using the right proportions of ingredients ensures the cookies turn out as expected (not too runny or too dry), in a database, consistency ensures that all data remains accurate and in the correct format throughout any transaction.</p> <p><strong>Integrity</strong>, on the other hand, involves maintaining the accuracy and reliability of the data over its entire lifecycle. This means that the data in the database is always accurate, and any changes made to it are done correctly. Going back to our baking analogy, integrity is similar to ensuring that the sugar intended for your cookies isn’t mistakenly used in your mother’s cake.</p> <p>In summary, consistency and integrity in databases are like following a recipe and using the correct ingredients in baking. Just as each step and ingredient must be correctly followed and used to produce the desired cookie outcome, transactions in a database must adhere to rules that preserve <strong>data consistency and integrity</strong>, ensuring the database remains useful, accurate, and reliable.</p> <h1 id="definition">Definition</h1> <p><a href="https://www.geeksforgeeks.org/transaction-in-dbms/">GeeksForGeeks</a> defines a transaction as</p> <d-cite key="gregor2015draw">a set of logically related operations. It is the result of a request made by the user to access the contents of the database and perform operations on it. It consists of various operations and has various states in its completion journey. It also has some specific properties that must be followed to keep the database consistent.</d-cite> <h1 id="acid">ACID</h1> <p>These proprieties mentioned in the definition followed by transactions are usually referred to has <strong>ACID properties</strong>, they are <strong>Atomicity</strong>, <strong>Consistency</strong>, <strong>Isolation</strong> and <strong>Durability</strong>. We already mentioned Consistency.</p> <p><strong>Atomicity</strong> ensures that a transaction is treated as a single unit of work, meaning, that it either completes in its entirety or it doesn’t happen at all. There is no in-between state. If any part of the transaction fails, the entire transaction is rolled back, and the database state is left unchanged as if the transaction never occurred. Baking cookies is not a good example for this, because, if you realize midway that your oven is broken, you can not return to a state where all the ingredients are separated and in their original container, but, I’m sure you get the idea.</p> <p><strong>Isolation</strong> ensures that transactions are securely isolated from each other. This means the operations of one transaction are hidden from other transactions until it’s completed. This property prevents transactions from interfering with each other, ensuring data integrity. Meaning, that the other transaction in your kitchen - your mother - can not interfere with your cookie baking. Like if both of you have separate workstations separate from each other.</p> <p><strong>Durability</strong> guarantees that once a transaction has been committed, it will remain so, even in the event of a power loss, crash, or error. This means the changes made by the transaction are permanently recorded in the database. Once the cookies are baked and taken out of the oven, they don’t magically disappear if the power goes out - only if you eat them, but that is another story.</p> <p>By adhering to these ACID properties, databases ensure that transactions are processed reliably, maintaining the integrity and consistency of the data.</p> <h1 id="operations">Operations</h1> <p>We mentioned before that a user can make different types of operations to access the contents of the database.</p> <p>The information in the database can be read - <strong>Read(X)</strong> - that is, the value is read from the database and stored in a buffer for displaying or other action. Like checking your account ballance online or your pantry to see if you have all the ingredients needed for the cookies. You are not taking anything out or using it.</p> <p>During a write operation we write - <strong>Write(X)</strong> the value from the memory buffer to the database. It must be preceded by a read operation during which the are brought to the buffer and some operations are performed on it - according to what the user requested. Then the modified value is written in the database. Think of checking you balance (Read) before you withdraw (Write) money from you bank account or you check what you have (Read) before putting all of your ingredients together (Write) to bake your cookies.</p> <p><strong>Commit</strong> is an operation that ensures that the integrity of the database is maintained. Operations are only made permanent after all of the work performed by the current transaction is completed, that is, the changes done by the transaction are made permanent in the database. There may be interruptions on transactions (like an error or a power failure), and this way we ensure that the consistency of the data is maintained. Imagine a Commit like you with or apron and the oven gloves with a batch of cookies ready for baking.</p> <p><strong>Rollback</strong> is intimately connected to the transaction, it’s what happens when a transaction is interrupted, all the operations are undone and the database returns to the original state. The cookie example is not a good one, but, it’s like if you decide that the batch isn’t good, and there is a operation that can return all the ingredients to the pantry.</p> <h1 id="deadlock">Deadlock</h1> <p>When a transaction needs to read or modify data, to ensure that no other transaction makes conflicting changes, it acquires <strong>locks</strong> to certain resources. When two or more transactions hold locks on resources the others need to complete their operations, and none can proceed until the other releases its locks. Each transaction is waiting for the other to finish, but neither can without the resources held by the other. This situation is called a <strong>deadlock</strong>.</p> <p>Deadlocks can significantly hinder database performance, leading to stalled transactions and system inefficiencies. To manage deadlocks, Database Management Systems (DBMS) employ various strategies, including <strong>deadlock detection algorithms</strong> that identify and break deadlocks by aborting one or more transactions to free up resources. Another approach is <strong>deadlock prevention</strong>, which involves designing the database and transactions in a way that avoids the conditions leading to deadlocks.</p> <p>Imagine you and your mother are both trying to bake in a kitchen with only one oven and one oven mint. If you both are ready to bake and you hold the mint and your mother the oven, neither of you can proceed creating “kitchen deadlock.” In databases, similar scenarios require careful management to ensure smooth operation.</p> <h1 id="conclusion">Conclusion</h1> <p>Transactions are fundamental to maintaining the <strong>consistency, integrity, and reliability</strong> of data in database systems. By understanding and implementing the ACID properties, databases can ensure that transactions are processed in a manner that preserves data integrity, even in the face of errors or system failures. Operations like <strong>Read, Write, Commit, and Rollback</strong> play crucial roles in transaction management, while mechanisms to handle deadlocks ensure that databases remain efficient and responsive.</p> <p>Just as following a recipe step by step leads to delicious cookies, adhering to transaction principles ensures that databases function effectively, supporting a wide range of applications from financial services to online shopping. Understanding transactions and their management is essential for anyone working with database systems, providing the foundation for building robust and reliable software solutions.</p> <h2 id="further-information">Further information</h2> <p><a href="https://www.geeksforgeeks.org/transaction-in-dbms/">Geeks for Geeks</a></p> <p><a href="https://www.tutorialspoint.com/dbms/dbms_transaction.htm">Tutorialspoint</a></p> <p><a href="https://www.javatpoint.com/dbms-transaction-processing-concept">Javapoint</a></p>]]></content><author><name></name></author><category term="dbms"/><category term="sql"/><category term="transaction"/><summary type="html"><![CDATA[a short explication of what is a transaction in the context of database management systems]]></summary></entry><entry><title type="html">challenge - two sum</title><link href="jjginga.com/blog/2024/two_sum/" rel="alternate" type="text/html" title="challenge - two sum"/><published>2024-02-29T00:00:00+00:00</published><updated>2024-02-29T00:00:00+00:00</updated><id>jjginga.com/blog/2024/two_sum</id><content type="html" xml:base="jjginga.com/blog/2024/two_sum/"><![CDATA[<h2 id="challenge">Challenge</h2> <p>I had never used leetcode before. In the last few years I spend some time in other similar platforms such has hackerank and codewars, but never leetcode. It crossed my path the other day in some random post on reddit where i read something like “everything starts with two sum”. So I decided to take a look. At first glance the problem <a href="https://leetcode.com/problems/two-sum/">Two Sum</a> seemed quite simple and reminded me of some other basic challenges I had encountered on other platforms. However, as I delved deeper, I realized there was more to this problem than met the eye</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Given an array of integers nums and an integer target, return indices of the two 
numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not 
use the same element twice.

You can return the answer in any order.
</code></pre></div></div> <p>For visualization purpose let’s take one of examples, if the input is nums = \([ 15 , 11 , 2 , 7 ]\) and target = 9, the output should be \([ 2 , 3 ]\) , the numbers at indices 2 and 3 (values 2 and 7, respectively) add up to the target value of 9.</p> <p>This problem is significant not only because it’s a common interview question but also because it serves as an accessible introduction to key concepts in computer science, including hashing, array manipulation, and the trade-offs between time and space complexity. Its simplicity allows for a focus on algorithmic thinking and optimization strategies without the overhead of complex data structures or algorithms. Moreover, the problem’s applicability to real-world scenarios, such as database queries or financial transactions, highlights the practical importance of efficient data processing and retrieval techniques, making it a relevant and engaging challenge for programmers at all levels.</p> <h2 id="initial-approach">Initial approach</h2> <p>In a problem like this the the straightforward approach, and I think the one that comes to most people minds is the use of brute force. That is, using a double loop to iterate through the array, comparing each pair of numbers to see if they added up to the target. This method it simple enough, but, it has a time complexity of $$ O ( n^2 ) $, it is far from optimal for larger arrays. Here is this approach in C++, Java and python. This was confirmed when I submitted the code and found that it was only faster than 30% of code submitted by other users.</p> <h2 id="c">C++</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> 
                <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> 
                    <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">};</span>
                        
        <span class="k">return</span> <span class="p">{};</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="java">Java</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span>

        <span class="nf">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">;</span> <span class="n">i</span> <span class="o">++)</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]==</span><span class="n">target</span><span class="o">)</span>
                    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">};</span>
      
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="python">python</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range </span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="nf">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="n">target</span><span class="p">):</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="p">[]</span>
</code></pre></div></div> <h2 id="time-efficient-with-hash-map">Time efficient with Hash Map</h2> <p>A resounding difference between leetcode and the other platforms I used before is the plethora of discussions, solutions and even videos. I always like to see how a problem can be tackled in multiple ways, each with its own trade-offs in terms of time and space complexity. So i revisited the problem, but this time armed with new insights and a hash table. The idea was to store each element’s value and its index in the array. As I iterated through the array, I checked if the complement of the current element (target - current element) was already in the hash table. If it was, I had found the two numbers.</p> <p>In a hash table the values are stored associating a specific key to corresponding values. To store and retrieve these values, an hashing function is used. This causes that the average complexity of search, insert and delete data in a hash table is of a \(O ( 1 )\) time complexity. This approach significantly reduced the time complexity to \(O ( n )\), a vast improvement over my initial brute-force method. But, unlike the brute force method that has a space complexity of \(O ( 1 )\), the space complexity is now \(O ( n )\), since in the worst case scenario we will need to store each element of the array in the hash map.</p> <h2 id="c-1">C++</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//initialize an unordered_map to store the array values and their indices</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">numMap</span><span class="p">;</span>

        <span class="c1">//iterate through the array</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span>  <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="c1">//calculate the complement by subtracting the current value to the target</span>
            <span class="kt">int</span> <span class="n">complement</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="c1">//check if the element exists in the map</span>
            <span class="k">if</span><span class="p">(</span><span class="n">numMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">complement</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
                <span class="c1">//if found, return the indices of the current value and its complement</span>
                <span class="k">return</span><span class="p">{</span><span class="n">numMap</span><span class="p">[</span><span class="n">complement</span><span class="p">],</span> <span class="n">i</span><span class="p">};</span>
            <span class="c1">//store the current value and it's index in the map</span>
            <span class="n">numMap</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>   

        <span class="k">return</span> <span class="p">{};</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="java-1">Java</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//create an HashMap to store the array values and their indices</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span>  <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        
        <span class="c1">//iterate through the array</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">;</span> <span class="n">i</span> <span class="o">++){</span>
            <span class="c1">//calculate the complement by subtracting the current value to the target</span>
            <span class="kt">int</span> <span class="n">complement</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="c1">//check if the element exists in the map</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">complement</span><span class="o">))</span>
                <span class="c1">//if found, return the indices of the current value and its complement</span>
                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">complement</span><span class="o">),</span><span class="n">i</span><span class="o">};</span>
            <span class="c1">//store the current value and it's index in the map</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="python-1">python</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># initialize the set to store the array values and their indices
</span>        <span class="n">nums_set</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
        
        <span class="c1"># iterate through the array
</span>        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="c1"># calculate the complement by subtracting the current value to the target
</span>            <span class="n">complement</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">num</span>
            <span class="c1">#check if the complement exists in the set
</span>            <span class="k">if</span> <span class="n">complement</span> <span class="ow">in</span> <span class="n">nums_set</span><span class="p">:</span>
                <span class="c1"># if found, return the indices of the current value and its complement
</span>                <span class="k">return</span> <span class="p">[</span><span class="n">nums</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">complement</span><span class="p">),</span> <span class="n">nums</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="c1">#store the current number in the set
</span>            <span class="n">nums_set</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">[]</span>
</code></pre></div></div> <p>This approach parachuted me to be faster than 80% of other submissions in C++ and to the 98% faster in Java and python.</p> <h2 id="alternative-approach">Alternative approach</h2> <p>While the hash table approach significantly improves the time efficiency, it does introduce a higher space complexity of \(O ( n )\). This got me thinking if whether there’s a middle ground that could offer a better balance between time and space efficiency.</p> <p>A potential approach is to consider the two pointer technique, applicable if the array is sorted or if sorting doesn’t affect the solution’s correctness. This method involves placing one pointer at the beginning of the array and another at the end and then moving them towards each other until the target sum is found. The time complexity is then \(O ( n \log n)\) from the sorting and the space complexity is \(O ( n )\).</p> <h2 id="c-2">C++</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="c1">//create vector to store pairs of numbers and their original indices</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">vector</span><span class="p">;</span>
        
        <span class="c1">//populate the vector with the pairs</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="p">));</span>

        <span class="c1">//sort the vector based on the numeric value</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">vector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
            <span class="p">[](</span><span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">){</span>
                <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
            <span class="p">});</span>
        
        <span class="c1">//initialize the pointers</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        
        
        <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">){</span>
            <span class="c1">//calculate the sum of the two pointed values</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="n">left</span><span class="p">].</span><span class="n">first</span><span class="o">+</span><span class="n">vector</span><span class="p">[</span><span class="n">right</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
            
            <span class="c1">//if the sum matches the target, we return the original indices of the two</span>
            <span class="k">if</span><span class="p">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">{</span> <span class="n">vector</span><span class="p">[</span><span class="n">left</span><span class="p">].</span><span class="n">second</span><span class="p">,</span> <span class="n">vector</span><span class="p">[</span><span class="n">right</span><span class="p">].</span><span class="n">second</span><span class="p">};</span>
            
            <span class="c1">//if the sum is less than the target, move the left pointer to the right</span>
            <span class="c1">//that is, we increase the left value</span>
            <span class="k">if</span><span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">){</span>
                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="c1">//if the sum is greater than the target, we move the right pointer to the left</span>
            <span class="n">right</span><span class="o">--</span><span class="p">;</span>
            
        <span class="p">}</span>
 
        <span class="k">return</span> <span class="p">{};</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="java-2">Java</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//create an array with the numbers and their indices</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">numsWithIndices</span> <span class="o">=</span> <span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
                                           <span class="o">.</span><span class="na">mapToObj</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">})</span>
                                           <span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]::</span><span class="k">new</span><span class="o">);</span>
        
        <span class="c1">//sort the array based on the numeric vlaues</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">numsWithIndices</span><span class="o">,</span> <span class="nc">Comparator</span><span class="o">.</span><span class="na">comparingInt</span><span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>

        <span class="c1">//initialize the two pointers</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        

        <span class="c1">//iterate through the array using the two pointers</span>
        <span class="k">while</span><span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
            <span class="c1">//calculate the sum of the two pointed values</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">numsWithIndices</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="mi">0</span><span class="o">]+</span><span class="n">numsWithIndices</span><span class="o">[</span><span class="n">right</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            
            <span class="c1">//if the sum matches the target, we return the original indices of the two</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span><span class="o">==</span><span class="n">target</span><span class="o">)</span>
                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">numsWithIndices</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="n">numsWithIndices</span><span class="o">[</span><span class="n">right</span><span class="o">][</span><span class="mi">1</span><span class="o">]};</span>
            
            <span class="c1">//if the sum is less than the target, move the left pointer to the right</span>
            <span class="c1">//that is, we increase the left value</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">left</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="c1">//if the sum is greater than the target, we move the right pointer to the left</span>
            <span class="n">right</span><span class="o">--;</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="python-2">python</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># create an array of tuples of the numbers and the original indices, sorted by the number
</span>        <span class="n">numsWithIndices</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">((</span><span class="n">num</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>
        
        <span class="c1"># initialize the pointers
</span>        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        
        <span class="c1"># iterate through the array using the two pointers
</span>        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="c1"># calculate the sum of the two pointed values
</span>            <span class="nb">sum</span> <span class="o">=</span> <span class="n">numsWithIndices</span><span class="p">[</span><span class="n">left</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">numsWithIndices</span><span class="p">[</span><span class="n">right</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># if the sum matches the target, we return the original indices of the two
</span>            <span class="k">if</span> <span class="nb">sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">numsWithIndices</span><span class="p">[</span><span class="n">left</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">numsWithIndices</span><span class="p">[</span><span class="n">right</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
            
            <span class="c1">#if the sum is less than the target, move the left pointer to the right
</span>            <span class="k">if</span> <span class="nb">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            
            <span class="c1">#if the sum is greater than the target, we move the right pointer to the left
</span>            <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="p">[]</span>
</code></pre></div></div> <h2 id="reflection">Reflection</h2> <p>The journey through solving the “Two Sum” problem on LeetCode has been enlightening. It showcased the importance of understanding both time and space complexity and how different approaches can significantly impact performance. From a brute-force method to a time-efficient hash table solution, and exploring a space-efficient two-pointer technique, each method provided valuable insights.</p> <p>The brute-force method, while straightforward, highlighted the importance of considering time complexity from the outset. The hash map solution, on the other hand, was a practical lesson in how space-time trade-offs work in algorithm design. Finally, the sorting and two-pointer technique provided a clear example of how sometimes a preliminary step (like sorting) can lead to more efficient solutions, even if it seems counterintuitive at first.</p> <h2 id="comparison-of-approaches">Comparison of Approaches</h2> <p>A comparison of these methods can offer valuable insights. Understanding the nuances of each approach allows developers to make more informed decisions when faced with similar problems.</p> <table> <thead> <tr> <th> </th> <th style="text-align: center">Time Complexity</th> <th style="text-align: center">Space Complexity</th> <th style="text-align: center">Readability</th> </tr> </thead> <tbody> <tr> <td>Brute-Force</td> <td style="text-align: center">\(O ( n^2 )\)</td> <td style="text-align: center">\(O ( 1 )\)</td> <td style="text-align: center">High</td> </tr> <tr> <td>Hash Map</td> <td style="text-align: center">\(O ( n )\)</td> <td style="text-align: center">\(O ( n )\)</td> <td style="text-align: center">Moderate</td> </tr> <tr> <td>Two-Pointer</td> <td style="text-align: center">\(O ( n \log n )\)</td> <td style="text-align: center">\(O ( n )\)</td> <td style="text-align: center">Moderate</td> </tr> </tbody> </table> <p>Choosing the right approach depends on several factors, including the size of the input data, the computational resources available, and the specific requirements of the application. By carefully considering these aspects, developers can select the most appropriate solution, optimizing for performance, readability, and resource usage as needed.</p> <p>So, Brute-force also has its advantages, it is the more readable solution and simple implementation. If we have small datasets, if the simplicity and readability are more important than efficiency concerns, or if our system has limited memory this solution may be ideal. If we have large data-sets and are in a performance-sensitive application, the reduction of the execution time from the constant-time lookups make this solution ideal. On the other hand the Two-Pointer technique is ideal for medium to large datasets where a balance between time and space efficiency is desired. This method is particularly useful when the input array can be sorted without affecting the solution’s correctness, offering a good compromise between the brute-force and hash map approaches.</p> <p>We can also analyze the performance in terms of execution time and memory usage in the leetcode platform for each programming language</p> <table> <thead> <tr> <th>Approach</th> <th>Language</th> <th>Best Time (ms)</th> <th>Best Memory (MB)</th> </tr> </thead> <tbody> <tr> <td>Brute-Force</td> <td>Java</td> <td>44</td> <td>44.6</td> </tr> <tr> <td> </td> <td>C++</td> <td>9</td> <td>14.2</td> </tr> <tr> <td> </td> <td>Python3</td> <td>1681</td> <td>17.3</td> </tr> <tr> <td>Hash Map</td> <td>Java</td> <td>2</td> <td>45.3</td> </tr> <tr> <td> </td> <td>C++</td> <td>8</td> <td>14.1</td> </tr> <tr> <td> </td> <td>Python3</td> <td>49</td> <td>17.8</td> </tr> <tr> <td>Two-Pointers</td> <td>Java</td> <td>9</td> <td>44.1</td> </tr> <tr> <td> </td> <td>C++</td> <td>3</td> <td>13.5</td> </tr> <tr> <td> </td> <td>Python3</td> <td>60</td> <td>18</td> </tr> </tbody> </table> <p>The Hash Map approach shows the best performance in Java, significantly reducing the execution time to 2 ms, which is a substantial improvement over the Brute-Force and Two-Pointers methods. This demonstrates the efficiency of hash maps in optimizing lookup operations, making it the preferred choice for large datasets where time complexity is a critical factor.</p> <p>C++ implementations consistently show low execution times across all approaches, with the Hash Map and Two-Pointers methods being particularly efficient. This underscores C++’s performance advantages, especially in memory usage, where it outperforms the other languages.</p> <p>Python, while not matching the execution speeds of Java and C++, benefits significantly from the Hash Map approach, reducing its execution time to 49 ms from the much slower brute-force implementation. This illustrates Python’s effective use of dynamic data structures like dictionaries for optimizing time complexity, albeit with a higher space complexity.</p> <p>The performance results for each approach in different programming languages also highlights the impact of language-specific optimizations and data structure implementations on algorithm efficiency. For instance, Java’s significant time reduction using hash maps can be attributed to its highly optimized HashMap class, while C++’s lower memory usage reflects the language’s close-to-hardware design, allowing for more controlled memory management. Python’s slower execution times, compared to C++ and Java, underscore the trade-offs of using a dynamically typed, interpreted language, which prioritizes development speed and ease of use over raw performance. These variations underscore the importance of choosing the right tool for the job, considering both the problem at hand and the execution environment.</p> <h2 id="conclusion">Conclusion</h2> <p>The “Two Sum” problem, in its simplicity and complexity, serves as a microcosm of the broader journey in computer science—a journey of continuous learning, problem-solving, and growth. The exploration of different solutions not only deepens our understanding of algorithmic efficiency but also equips us with a versatile toolkit for approaching future coding challenges. Recognizing when to use a brute-force method for its simplicity, a hash map for its time efficiency, or a two-pointer technique for a balanced approach can drastically improve our problem-solving strategies. These insights encourage a more nuanced consideration of trade-offs in algorithm design, preparing us to tackle a wide range of problems with informed decision-making about when and how to optimize for time, space, and code readability.</p> <p>This exploration has not only enhanced my problem-solving toolkit but also sharpened my decision-making skills, teaching me to weigh the trade-offs between different approaches based on the problem’s requirements. As I move forward, these insights will be invaluable, guiding me through future challenges with a deeper understanding of when and how to apply each method effectively.</p>]]></content><author><name></name></author><category term="leetcode"/><category term="array"/><category term="hashmap"/><category term="timecomplexity"/><category term="spacecomplexity"/><category term="leetcode"/><summary type="html"><![CDATA[to find two numbers in an array that sum up to a given target value.]]></summary></entry><entry><title type="html">challenge - binary multiple of 3</title><link href="jjginga.com/blog/2024/binary_multiple_of_3/" rel="alternate" type="text/html" title="challenge - binary multiple of 3"/><published>2024-02-28T00:00:00+00:00</published><updated>2024-02-28T00:00:00+00:00</updated><id>jjginga.com/blog/2024/binary_multiple_of_3</id><content type="html" xml:base="jjginga.com/blog/2024/binary_multiple_of_3/"><![CDATA[<h2 id="challenge">Challenge</h2> <p>After I run my marathon I took some days to rest by the sea. Little did I know that instead of a conventional boat I would embark on a computational odyssey where on a sea of zeros and ones. It happened when I crossed paths with <a href="https://www.codewars.com/kata/54de279df565808f8b00126a">this CodeWars kata</a>. It seemed simple, since I only had to create a regex expression. And it had a hight reward - 4 kata. So, I decided to take a try. After all, I just had to find a pattern amidst the cascade of 0s and 1s of the binary numbers multiple of 3.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>In this kata, your task is to create a regular expression capable of evaluating binary 
strings (strings with only 1s and 0s) and determining whether the given string 
represents a number divisible by 3.

Take into account that:

An empty string might be evaluated to true (it's not going to be tested, so you don't 
need to worry about it - unless you want)
The input should consist only of binary digits - no spaces, other digits, alphanumeric
 characters, etc.
There might be leading 0s.
</code></pre></div></div> <h2 id="journey">Journey</h2> <p>I started by writting a bunch of binary representations of multiples of 3, in the hope of finding a pattern visually.</p> <table> <thead> <tr> <th>Decimal</th> <th style="text-align: center">Binary</th> </tr> </thead> <tbody> <tr> <td>3</td> <td style="text-align: center">11</td> </tr> <tr> <td>6</td> <td style="text-align: center">110</td> </tr> <tr> <td>9</td> <td style="text-align: center">1001</td> </tr> <tr> <td>12</td> <td style="text-align: center">1100</td> </tr> <tr> <td>15</td> <td style="text-align: center">1111</td> </tr> <tr> <td>18</td> <td style="text-align: center">10010</td> </tr> <tr> <td>21</td> <td style="text-align: center">10101</td> </tr> <tr> <td>24</td> <td style="text-align: center">11000</td> </tr> <tr> <td>27</td> <td style="text-align: center">11011</td> </tr> <tr> <td>30</td> <td style="text-align: center">11110</td> </tr> </tbody> </table> <p>There is one, but I wasn’t able to recognize it, but a quick search on the internet showed me that if I sum all the odd-positioned bits and subtract to it the sum of all of the even-position bits and get a result that is divisible by 3, then the original binary number is also divisible by 3.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>27 in binary is 11011
odd bits: 1+0+1 = 2
even bitts: 1+1 = 2
different: 2-2 = 0, hence 27 is divisible by 3.
</code></pre></div></div> <p>Converting this logic to a regular expression is not straightforward, they work well for pattern matching and not for mathematical operations. So, it hit me. I could use an Automata. The Automata would have states representing the remainder when divided by 3 (the possible remainders are 0, 1 and 2), and transactions based on the next binary digit. And we could then determine the divisibility by 3 by observing the state after processing all the bits.</p> <p>With the available info it is easy to design the following DFA</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DFA-480.webp 480w,/assets/img/DFA-800.webp 800w,/assets/img/DFA-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DFA.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <p>We could directly write a regular expression from this DFA, bur we can do better than that. We start by defining it mathematically</p> <p>Given the DFA \(( M = (Q, \Sigma, \delta, q_0, F) )\), where:</p> \[( Q = { q_0, q_1, q_2 } ) ( \Sigma = { 0, 1 } ) ( \delta )\] <p>is defined by the transitions:</p> \[\begin{aligned} \delta(q_0, 0) &amp;= q_0 \\ \delta(q_0, 1) &amp;= q_1 \\ \delta(q_1, 0) &amp;= q_2 \\ \delta(q_1, 1) &amp;= q_0 \\ \delta(q_2, 0) &amp;= q_1 \\ \delta(q_2, 1) &amp;= q_2 \end{aligned}\] <p>\(( q_0 )\) is the start state</p> <p>\(( F = { q_0 } )\) is the set of accept states</p> <p>Then we can start by writting the equations for all the states:</p> \[q_0 = \epsilon + q_0 0 + q_1 1 q_1 = q_0 1 + q_2 0 q_2 = q_1 0 + q_2 1\] <p>To simplify \(q_2\) and \(q_1\) we can use <a href="https://www.geeksforgeeks.org/ardens-theorem-in-theory-of-computation/">Arden’s theorem</a>. We first note that the theorem states that if a regular expression \(R\) satisfies the equation \(R = Q + RP\), where \(Q\) and \(P\) are regular expressions and \(P\) does not contain the empty string \(\epsilon\) then \(R = QP*\) is a solution for the equation.</p> <p>Applying it to \(q_2\) we get \(q_2 = ( q_1 0 ) ( 1 * )\) - this represents the language accepted by \(q_1\) followed by a 0 and then any number of 1s.</p> <p>Now substituting this on the equation for \(q_1\) we get \(q_1 = q_0 1 + ( q_1 0 ) (\ 1 * ) 0\).</p> <p>We can now apply Arden’s Theorem again: \(q_1 = ( q_0 1 ) ( 0 ( 1 * ) 0 ) *\) - and you get the language accepted by \(q_0\) followed by a 1 and then any number of repetitions starting with 0, followed by zero or more 1s and ending with 0.</p> <p>Now we can write \(q_0 = \epsilon + q_0 0 + q_0 1 ( 0 ( 1 * ) 0 ) * 1 = \epsilon + q_0 ( 0 + 1 ( 0 ( 1 * ) 0 ) * 1 )\).</p> <p>Applying Arden’s Theorem again we get:</p> \[q_0 = ( \epsilon ) ( 0 + 1 ( 0 ( 1 * ) 0 ) * 1 ) *\] <p>That can be further simplified to</p> \[q_0 = ( \epsilon ) ( 0 + 1 ( 0 ( 1 * ) 0 ) * 1 ) *\] <p>This is the final expression for \(q_0\) that describe all the strings accepted by the automata that start and end in this state.</p> <h2 id="solution-and-reflection">Solution and reflection</h2> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">multiple_of_3_regex</span> <span class="o">=</span> <span class="s">"^(0|1(01*0)*1)*$"</span><span class="p">;</span></code></pre></figure> <p>It’s fascinating how theoretical computer science principles blend into practical programming challenges. It’s a vivid reminder that beneath every line of code lies a rich tapestry of logic and mathematics, waiting to be explored and appreciated. Every challenge is not just a test of skill, but an invitation to an intellectual adventure, revealing the interconnectedness of concepts we sometimes take for granted.</p> <h2 id="further-information">Further information</h2> <p><a href="https://www.geeksforgeeks.org/ardens-theorem-in-theory-of-computation/">Arden’s theorem</a> <a href="https://www.youtube.com/watch?v=SmT1DXLl3f4">Khan Academy - DFA to Regular Expression</a></p>]]></content><author><name></name></author><category term="regex"/><category term="codewars"/><category term="regex"/><category term="dfa"/><category term="binary"/><category term="codewars"/><summary type="html"><![CDATA[the challenge was to create a regular expression capable of recognizing multiples of 3.]]></summary></entry><entry><title type="html">Not so Agile Marathon</title><link href="jjginga.com/blog/2024/not-so-agile-marathon/" rel="alternate" type="text/html" title="Not so Agile Marathon"/><published>2024-02-24T20:00:00+00:00</published><updated>2024-02-24T20:00:00+00:00</updated><id>jjginga.com/blog/2024/not-so-agile-marathon</id><content type="html" xml:base="jjginga.com/blog/2024/not-so-agile-marathon/"><![CDATA[<div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/medal_seville-480.webp 480w,/assets/img/medal_seville-800.webp 800w,/assets/img/medal_seville-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/medal_seville.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>In preparing for a marathon, I embarked on a long-term project that spanned several months. It’s accurate to say I engaged in a series of sprints to prepare for my marathon, both figuratively, analogous to multiple sprints in an Agile framework, and literally. My training included ‘iterations’ of high effort followed by rest, mirroring the sprint-and-pause rhythm of interval training. But in a whimsical twist of language, these bursts of speed are known as “series” in Portuguese, giving a whole new meaning to running a series of sprints before the actual Sprint.</p> <p>The objective was clear: complete the marathon within a target time, serving as my project’s final goal. The training was divided into four phases, each with its own objectives, akin to sprint goals in Agile: enhancing overall fitness, boosting speed, increasing endurance, and ultimately tapering for the marathon. These phases were further broken down into smaller increments, approximately a week long—my sprint durations—culminating in a long run each Sunday, my deliverable.</p> <p>Given that running isn’t my primary activity—I balance both work and study—the normal adjustments from learning through experience were complemented by others, tailored to fit my circumstances. Typically, my sprint planning occurred on Mondays, where I would assess the previous week’s training and establish my commitments based on my velocity and past performances. Despite my initial fitness level, the goals were met.</p> <p>A marathon is so extensive that it could be seen both as a sprint – although my pace is far from swift – and as a goal. This happens because in a 42km race, time feels dilated, when you are running 4h41 minutes feel like more than a week. So as race day neared, I conducted my final planning, electing to gi with the 4:30-hour pace group. This was a realistic commitment, in line with in the achievements of earlier project phases.</p> <p>However, once the race day arrived—our sprint began—I faced a challenge. The pace set by the 4:30 group misaligned with my natural running rhythm; it felt too slow, especially in the flat terrain of Seville, making it increasingly hard to maintain, and I started to accelerate. Despite knowing from past marathons that this strategy would lead me to failure, overconfidence and a desire to outperform my expectations—a common pitfall in both running and Agile projects—led me to put aside what I learned from previous experience. Like a team realizing early in a sprint that their approach might not deliver the sprint goal due to external factors or misestimations, yet failing to adjust accordingly.</p> <p>I decided to adapt my strategy on the fly, aiming for a 4-hour finish, exceeding my initial expectations. By the 20km mark, it was evident things weren’t going as planned, but I continued, one kilometer at a time, maintaining my pace against the odds.</p> <p>Unfortunately, this led to a significant challenge at the 30km mark, where I “hit the wall,” or as we say in Portuguese, “o homem da marreta apanhou-me”—no direct translation can encapsulate this expression, the idea is that while you are running a marathon you are being chased by someone with a giant hammer, ready to strike if they catch you. He caught with me and hit me with the hammers, like a team realizing too late that they’ve overcommitted or misjudged their capacity, resulting in burnout or unfinished work.</p> <p>I ended up finishing in 4h41 minutes. I did 30km in 3h and I basically crawled the rest of the way. If I had gone with the 4h30 group the experience wouldn’t be as painful as it was.</p> <p>Reflecting on this experience, the importance of the Agile principle of inspecting and adapting becomes clear. Just as Agile uses retrospectives to reflect on what worked, what didn’t, and how to improve, I must take this opportunity to learn from both the race and the training leading up to it. Recognizing the significance of pacing, the limits of my current capabilities, and the need for strategy adjustments based on real-time feedback are all invaluable lessons.</p> <p>For my next race—our next project or sprint cycle—I’ll approach with a focus on realistic goal setting, continuous performance adjustment, and maintaining a sustainable pace. The aim is not only to reach the finish line but to do so smiling instead of crawling.</p>]]></content><author><name></name></author><category term="agile"/><category term="agile"/><category term="marathon"/><summary type="html"><![CDATA[reflecting on this experience, the importance of the agile principle of inspecting and adapting becomes clear.]]></summary></entry></feed>