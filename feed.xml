<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="jjginga.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="jjginga.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-03-02T16:26:18+00:00</updated><id>jjginga.github.io/feed.xml</id><title type="html">blank</title><subtitle>Code whisperer by day, bug hunter by night, crafting digital magic with a sprinkle of caffeine and a dash of humor. </subtitle><entry><title type="html">challenge - two sum</title><link href="jjginga.github.io/blog/2024/two_sum/" rel="alternate" type="text/html" title="challenge - two sum"/><published>2024-02-29T00:00:00+00:00</published><updated>2024-02-29T00:00:00+00:00</updated><id>jjginga.github.io/blog/2024/two_sum</id><content type="html" xml:base="jjginga.github.io/blog/2024/two_sum/"><![CDATA[<h2 id="challenge">Challenge</h2> <p>I had never used leetcode before. In the last few years I spend some time in other similar platforms such has hackerank and codewars, but never leetcode. It crossed my path the other day in some random post on reddit where i read something like “everything starts with two sum”. So I decided to take a look. At first glance the problem <a href="https://leetcode.com/problems/two-sum/">Two Sum</a> seemed quite simple and reminded me of some other basic challenges I had encountered on other platforms. However, as I delved deeper, I realized there was more to this problem than met the eye</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Given an array of integers nums and an integer target, return indices of the two 
numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not 
use the same element twice.

You can return the answer in any order.
</code></pre></div></div> <p>For visualization purpose let’s take one of examples, if the input is nums = \([ 15 , 11 , 2 , 7 ]\) and target = 9, the output should be \([ 2 , 3 ]\) , the numbers at indices 2 and 3 (values 2 and 7, respectively) add up to the target value of 9.</p> <p>This problem is significant not only because it’s a common interview question but also because it serves as an accessible introduction to key concepts in computer science, including hashing, array manipulation, and the trade-offs between time and space complexity. Its simplicity allows for a focus on algorithmic thinking and optimization strategies without the overhead of complex data structures or algorithms. Moreover, the problem’s applicability to real-world scenarios, such as database queries or financial transactions, highlights the practical importance of efficient data processing and retrieval techniques, making it a relevant and engaging challenge for programmers at all levels.</p> <h2 id="initial-approach">Initial approach</h2> <p>In a problem like this the the straightforward approach, and I think the one that comes to most people minds is the use of brute force. That is, using a double loop to iterate through the array, comparing each pair of numbers to see if they added up to the target. This method it simple enough, but, it has a time complexity of $$ O ( n^2 ) $, it is far from optimal for larger arrays. Here is this approach in C++, Java and python. This was confirmed when I submitted the code and found that it was only faster than 30% of code submitted by other users.</p> <h2 id="c">C++</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> 
                <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> 
                    <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">};</span>
                        
        <span class="k">return</span> <span class="p">{};</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="java">Java</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span>

        <span class="nf">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">;</span> <span class="n">i</span> <span class="o">++)</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]==</span><span class="n">target</span><span class="o">)</span>
                    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">};</span>
      
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="python">python</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range </span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="nf">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="n">target</span><span class="p">):</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="p">[]</span>
</code></pre></div></div> <h2 id="time-efficient-with-hash-map">Time efficient with Hash Map</h2> <p>A resounding difference between leetcode and the other platforms I used before is the plethora of discussions, solutions and even videos. I always like to see how a problem can be tackled in multiple ways, each with its own trade-offs in terms of time and space complexity. So i revisited the problem, but this time armed with new insights and a hash table. The idea was to store each element’s value and its index in the array. As I iterated through the array, I checked if the complement of the current element (target - current element) was already in the hash table. If it was, I had found the two numbers.</p> <p>In a hash table the values are stored associating a specific key to corresponding values. To store and retrieve these values, an hashing function is used. This causes that the average complexity of search, insert and delete data in a hash table is of a \(O ( 1 )\) time complexity. This approach significantly reduced the time complexity to \(O ( n )\), a vast improvement over my initial brute-force method. But, unlike the brute force method that has a space complexity of \(O ( 1 )\), the space complexity is now \(O ( n )\), since in the worst case scenario we will need to store each element of the array in the hash map.</p> <h2 id="c-1">C++</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//initialize an unordered_map to store the array values and their indices</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">numMap</span><span class="p">;</span>

        <span class="c1">//iterate through the array</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span>  <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="c1">//calculate the complement by subtracting the current value to the target</span>
            <span class="kt">int</span> <span class="n">complement</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="c1">//check if the element exists in the map</span>
            <span class="k">if</span><span class="p">(</span><span class="n">numMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">complement</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
                <span class="c1">//if found, return the indices of the current value and its complement</span>
                <span class="k">return</span><span class="p">{</span><span class="n">numMap</span><span class="p">[</span><span class="n">complement</span><span class="p">],</span> <span class="n">i</span><span class="p">};</span>
            <span class="c1">//store the current value and it's index in the map</span>
            <span class="n">numMap</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>   

        <span class="k">return</span> <span class="p">{};</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="java-1">Java</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//create an HashMap to store the array values and their indices</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span>  <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        
        <span class="c1">//iterate through the array</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">;</span> <span class="n">i</span> <span class="o">++){</span>
            <span class="c1">//calculate the complement by subtracting the current value to the target</span>
            <span class="kt">int</span> <span class="n">complement</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="c1">//check if the element exists in the map</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">complement</span><span class="o">))</span>
                <span class="c1">//if found, return the indices of the current value and its complement</span>
                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">complement</span><span class="o">),</span><span class="n">i</span><span class="o">};</span>
            <span class="c1">//store the current value and it's index in the map</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="python-1">python</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># initialize the set to store the array values and their indices
</span>        <span class="n">nums_set</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
        
        <span class="c1"># iterate through the array
</span>        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="c1"># calculate the complement by subtracting the current value to the target
</span>            <span class="n">complement</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">num</span>
            <span class="c1">#check if the complement exists in the set
</span>            <span class="k">if</span> <span class="n">complement</span> <span class="ow">in</span> <span class="n">nums_set</span><span class="p">:</span>
                <span class="c1"># if found, return the indices of the current value and its complement
</span>                <span class="k">return</span> <span class="p">[</span><span class="n">nums</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">complement</span><span class="p">),</span> <span class="n">nums</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="c1">#store the current number in the set
</span>            <span class="n">nums_set</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">[]</span>
</code></pre></div></div> <p>This approach parachuted me to be faster than 80% of other submissions in C++ and to the 98% faster in Java and python.</p> <h2 id="alternative-approach">Alternative approach</h2> <p>While the hash table approach significantly improves the time efficiency, it does introduce a higher space complexity of \(O ( n )\). This got me thinking if whether there’s a middle ground that could offer a better balance between time and space efficiency.</p> <p>A potential approach is to consider the two pointer technique, applicable if the array is sorted or if sorting doesn’t affect the solution’s correctness. This method involves placing one pointer at the beginning of the array and another at the end and then moving them towards each other until the target sum is found. The time complexity is then \(O ( n \log n)\) from the sorting and the space complexity is \(O ( n )\).</p> <h2 id="c-2">C++</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="c1">//create vector to store pairs of numbers and their original indices</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">vector</span><span class="p">;</span>
        
        <span class="c1">//populate the vector with the pairs</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="p">));</span>

        <span class="c1">//sort the vector based on the numeric value</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">vector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
            <span class="p">[](</span><span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">){</span>
                <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
            <span class="p">});</span>
        
        <span class="c1">//initialize the pointers</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        
        
        <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">){</span>
            <span class="c1">//calculate the sum of the two pointed values</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="n">left</span><span class="p">].</span><span class="n">first</span><span class="o">+</span><span class="n">vector</span><span class="p">[</span><span class="n">right</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
            
            <span class="c1">//if the sum matches the target, we return the original indices of the two</span>
            <span class="k">if</span><span class="p">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">{</span> <span class="n">vector</span><span class="p">[</span><span class="n">left</span><span class="p">].</span><span class="n">second</span><span class="p">,</span> <span class="n">vector</span><span class="p">[</span><span class="n">right</span><span class="p">].</span><span class="n">second</span><span class="p">};</span>
            
            <span class="c1">//if the sum is less than the target, move the left pointer to the right</span>
            <span class="c1">//that is, we increase the left value</span>
            <span class="k">if</span><span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">){</span>
                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="c1">//if the sum is greater than the target, we move the right pointer to the left</span>
            <span class="n">right</span><span class="o">--</span><span class="p">;</span>
            
        <span class="p">}</span>
 
        <span class="k">return</span> <span class="p">{};</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="java-2">Java</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//create an array with the numbers and their indices</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">numsWithIndices</span> <span class="o">=</span> <span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
                                           <span class="o">.</span><span class="na">mapToObj</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">})</span>
                                           <span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]::</span><span class="k">new</span><span class="o">);</span>
        
        <span class="c1">//sort the array based on the numeric vlaues</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">numsWithIndices</span><span class="o">,</span> <span class="nc">Comparator</span><span class="o">.</span><span class="na">comparingInt</span><span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>

        <span class="c1">//initialize the two pointers</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        

        <span class="c1">//iterate through the array using the two pointers</span>
        <span class="k">while</span><span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
            <span class="c1">//calculate the sum of the two pointed values</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">numsWithIndices</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="mi">0</span><span class="o">]+</span><span class="n">numsWithIndices</span><span class="o">[</span><span class="n">right</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            
            <span class="c1">//if the sum matches the target, we return the original indices of the two</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span><span class="o">==</span><span class="n">target</span><span class="o">)</span>
                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">numsWithIndices</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="n">numsWithIndices</span><span class="o">[</span><span class="n">right</span><span class="o">][</span><span class="mi">1</span><span class="o">]};</span>
            
            <span class="c1">//if the sum is less than the target, move the left pointer to the right</span>
            <span class="c1">//that is, we increase the left value</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">left</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="c1">//if the sum is greater than the target, we move the right pointer to the left</span>
            <span class="n">right</span><span class="o">--;</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="python-2">python</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># create an array of tuples of the numbers and the original indices, sorted by the number
</span>        <span class="n">numsWithIndices</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">((</span><span class="n">num</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>
        
        <span class="c1"># initialize the pointers
</span>        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        
        <span class="c1"># iterate through the array using the two pointers
</span>        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="c1"># calculate the sum of the two pointed values
</span>            <span class="nb">sum</span> <span class="o">=</span> <span class="n">numsWithIndices</span><span class="p">[</span><span class="n">left</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">numsWithIndices</span><span class="p">[</span><span class="n">right</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># if the sum matches the target, we return the original indices of the two
</span>            <span class="k">if</span> <span class="nb">sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">numsWithIndices</span><span class="p">[</span><span class="n">left</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">numsWithIndices</span><span class="p">[</span><span class="n">right</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
            
            <span class="c1">#if the sum is less than the target, move the left pointer to the right
</span>            <span class="k">if</span> <span class="nb">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            
            <span class="c1">#if the sum is greater than the target, we move the right pointer to the left
</span>            <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="p">[]</span>
</code></pre></div></div> <h2 id="reflection">Reflection</h2> <p>The journey through solving the “Two Sum” problem on LeetCode has been enlightening. It showcased the importance of understanding both time and space complexity and how different approaches can significantly impact performance. From a brute-force method to a time-efficient hash table solution, and exploring a space-efficient two-pointer technique, each method provided valuable insights.</p> <p>The brute-force method, while straightforward, highlighted the importance of considering time complexity from the outset. The hash map solution, on the other hand, was a practical lesson in how space-time trade-offs work in algorithm design. Finally, the sorting and two-pointer technique provided a clear example of how sometimes a preliminary step (like sorting) can lead to more efficient solutions, even if it seems counterintuitive at first.</p> <h2 id="comparison-of-approaches">Comparison of Approaches</h2> <p>A comparison of these methods can offer valuable insights. Understanding the nuances of each approach allows developers to make more informed decisions when faced with similar problems.</p> <table> <thead> <tr> <th> </th> <th style="text-align: center">Time Complexity</th> <th style="text-align: center">Space Complexity</th> <th style="text-align: center">Readability</th> </tr> </thead> <tbody> <tr> <td>Brute-Force</td> <td style="text-align: center">\(O ( n^2 )\)</td> <td style="text-align: center">\(O ( 1 )\)</td> <td style="text-align: center">High</td> </tr> <tr> <td>Hash Map</td> <td style="text-align: center">\(O ( n )\)</td> <td style="text-align: center">\(O ( n )\)</td> <td style="text-align: center">Moderate</td> </tr> <tr> <td>Two-Pointer</td> <td style="text-align: center">\(O ( n \log n )\)</td> <td style="text-align: center">\(O ( n )\)</td> <td style="text-align: center">Moderate</td> </tr> </tbody> </table> <p>Choosing the right approach depends on several factors, including the size of the input data, the computational resources available, and the specific requirements of the application. By carefully considering these aspects, developers can select the most appropriate solution, optimizing for performance, readability, and resource usage as needed.</p> <p>So, Brute-force also has its advantages, it is the more readable solution and simple implementation. If we have small datasets, if the simplicity and readability are more important than efficiency concerns, or if our system has limited memory this solution may be ideal. If we have large data-sets and are in a performance-sensitive application, the reduction of the execution time from the constant-time lookups make this solution ideal. On the other hand the Two-Pointer technique is ideal for medium to large datasets where a balance between time and space efficiency is desired. This method is particularly useful when the input array can be sorted without affecting the solution’s correctness, offering a good compromise between the brute-force and hash map approaches.</p> <p>We can also analyze the performance in terms of execution time and memory usage in the leetcode platform for each programming language</p> <table> <thead> <tr> <th>Approach</th> <th>Language</th> <th>Best Time (ms)</th> <th>Best Memory (MB)</th> </tr> </thead> <tbody> <tr> <td>Brute-Force</td> <td>Java</td> <td>44</td> <td>44.6</td> </tr> <tr> <td> </td> <td>C++</td> <td>9</td> <td>14.2</td> </tr> <tr> <td> </td> <td>Python3</td> <td>1681</td> <td>17.3</td> </tr> <tr> <td>Hash Map</td> <td>Java</td> <td>2</td> <td>45.3</td> </tr> <tr> <td> </td> <td>C++</td> <td>8</td> <td>14.1</td> </tr> <tr> <td> </td> <td>Python3</td> <td>49</td> <td>17.8</td> </tr> <tr> <td>Two-Pointers</td> <td>Java</td> <td>9</td> <td>44.1</td> </tr> <tr> <td> </td> <td>C++</td> <td>3</td> <td>13.5</td> </tr> <tr> <td> </td> <td>Python3</td> <td>60</td> <td>18</td> </tr> </tbody> </table> <p>The Hash Map approach shows the best performance in Java, significantly reducing the execution time to 2 ms, which is a substantial improvement over the Brute-Force and Two-Pointers methods. This demonstrates the efficiency of hash maps in optimizing lookup operations, making it the preferred choice for large datasets where time complexity is a critical factor.</p> <p>C++ implementations consistently show low execution times across all approaches, with the Hash Map and Two-Pointers methods being particularly efficient. This underscores C++’s performance advantages, especially in memory usage, where it outperforms the other languages.</p> <p>Python, while not matching the execution speeds of Java and C++, benefits significantly from the Hash Map approach, reducing its execution time to 49 ms from the much slower brute-force implementation. This illustrates Python’s effective use of dynamic data structures like dictionaries for optimizing time complexity, albeit with a higher space complexity.</p> <p>The performance results for each approach in different programming languages also highlights the impact of language-specific optimizations and data structure implementations on algorithm efficiency. For instance, Java’s significant time reduction using hash maps can be attributed to its highly optimized HashMap class, while C++’s lower memory usage reflects the language’s close-to-hardware design, allowing for more controlled memory management. Python’s slower execution times, compared to C++ and Java, underscore the trade-offs of using a dynamically typed, interpreted language, which prioritizes development speed and ease of use over raw performance. These variations underscore the importance of choosing the right tool for the job, considering both the problem at hand and the execution environment.</p> <h2 id="conclusion">Conclusion</h2> <p>The “Two Sum” problem, in its simplicity and complexity, serves as a microcosm of the broader journey in computer science—a journey of continuous learning, problem-solving, and growth. The exploration of different solutions not only deepens our understanding of algorithmic efficiency but also equips us with a versatile toolkit for approaching future coding challenges. Recognizing when to use a brute-force method for its simplicity, a hash map for its time efficiency, or a two-pointer technique for a balanced approach can drastically improve our problem-solving strategies. These insights encourage a more nuanced consideration of trade-offs in algorithm design, preparing us to tackle a wide range of problems with informed decision-making about when and how to optimize for time, space, and code readability.</p> <p>This exploration has not only enhanced my problem-solving toolkit but also sharpened my decision-making skills, teaching me to weigh the trade-offs between different approaches based on the problem’s requirements. As I move forward, these insights will be invaluable, guiding me through future challenges with a deeper understanding of when and how to apply each method effectively.</p>]]></content><author><name></name></author><category term="leetcode"/><category term="array"/><category term="hashmap"/><category term="timecomplexity"/><category term="spacecomplexity"/><category term="leetcode"/><summary type="html"><![CDATA[to find two numbers in an array that sum up to a given target value.]]></summary></entry><entry><title type="html">challenge - binary multiple of 3</title><link href="jjginga.github.io/blog/2024/binary_multiple_of_3/" rel="alternate" type="text/html" title="challenge - binary multiple of 3"/><published>2024-02-28T00:00:00+00:00</published><updated>2024-02-28T00:00:00+00:00</updated><id>jjginga.github.io/blog/2024/binary_multiple_of_3</id><content type="html" xml:base="jjginga.github.io/blog/2024/binary_multiple_of_3/"><![CDATA[<h2 id="challenge">Challenge</h2> <p>After I run my marathon I took some days to rest by the sea. Little did I know that instead of a conventional boat I would embark on a computational odyssey where on a sea of zeros and ones. It happened when I crossed paths with <a href="https://www.codewars.com/kata/54de279df565808f8b00126a">this CodeWars kata</a>. It seemed simple, since I only had to create a regex expression. And it had a hight reward - 4 kata. So, I decided to take a try. After all, I just had to find a pattern amidst the cascade of 0s and 1s of the binary numbers multiple of 3.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>In this kata, your task is to create a regular expression capable of evaluating binary 
strings (strings with only 1s and 0s) and determining whether the given string 
represents a number divisible by 3.

Take into account that:

An empty string might be evaluated to true (it's not going to be tested, so you don't 
need to worry about it - unless you want)
The input should consist only of binary digits - no spaces, other digits, alphanumeric
 characters, etc.
There might be leading 0s.
</code></pre></div></div> <h2 id="journey">Journey</h2> <p>I started by writting a bunch of binary representations of multiples of 3, in the hope of finding a pattern visually.</p> <table> <thead> <tr> <th>Decimal</th> <th style="text-align: center">Binary</th> </tr> </thead> <tbody> <tr> <td>3</td> <td style="text-align: center">11</td> </tr> <tr> <td>6</td> <td style="text-align: center">110</td> </tr> <tr> <td>9</td> <td style="text-align: center">1001</td> </tr> <tr> <td>12</td> <td style="text-align: center">1100</td> </tr> <tr> <td>15</td> <td style="text-align: center">1111</td> </tr> <tr> <td>18</td> <td style="text-align: center">10010</td> </tr> <tr> <td>21</td> <td style="text-align: center">10101</td> </tr> <tr> <td>24</td> <td style="text-align: center">11000</td> </tr> <tr> <td>27</td> <td style="text-align: center">11011</td> </tr> <tr> <td>30</td> <td style="text-align: center">11110</td> </tr> </tbody> </table> <p>There is one, but I wasn’t able to recognize it, but a quick search on the internet showed me that if I sum all the odd-positioned bits and subtract to it the sum of all of the even-position bits and get a result that is divisible by 3, then the original binary number is also divisible by 3.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>27 in binary is 11011
odd bits: 1+0+1 = 2
even bitts: 1+1 = 2
different: 2-2 = 0, hence 27 is divisible by 3.
</code></pre></div></div> <p>Converting this logic to a regular expression is not straightforward, they work well for pattern matching and not for mathematical operations. So, it hit me. I could use an Automata. The Automata would have states representing the remainder when divided by 3 (the possible remainders are 0, 1 and 2), and transactions based on the next binary digit. And we could then determine the divisibility by 3 by observing the state after processing all the bits.</p> <p>With the available info it is easy to design the following DFA</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DFA-480.webp 480w,/assets/img/DFA-800.webp 800w,/assets/img/DFA-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DFA.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <p>We could directly write a regular expression from this DFA, bur we can do better than that. We start by defining it mathematically</p> <p>Given the DFA \(( M = (Q, \Sigma, \delta, q_0, F) )\), where:</p> \[( Q = { q_0, q_1, q_2 } ) ( \Sigma = { 0, 1 } ) ( \delta )\] <p>is defined by the transitions:</p> \[\begin{aligned} \delta(q_0, 0) &amp;= q_0 \\ \delta(q_0, 1) &amp;= q_1 \\ \delta(q_1, 0) &amp;= q_2 \\ \delta(q_1, 1) &amp;= q_0 \\ \delta(q_2, 0) &amp;= q_1 \\ \delta(q_2, 1) &amp;= q_2 \end{aligned}\] <p>\(( q_0 )\) is the start state</p> <p>\(( F = { q_0 } )\) is the set of accept states</p> <p>Then we can start by writting the equations for all the states:</p> \[q_0 = \epsilon + q_0 0 + q_1 1 q_1 = q_0 1 + q_2 0 q_2 = q_1 0 + q_2 1\] <p>To simplify \(q_2\) and \(q_1\) we can use <a href="https://www.geeksforgeeks.org/ardens-theorem-in-theory-of-computation/">Arden’s theorem</a>. We first note that the theorem states that if a regular expression \(R\) satisfies the equation \(R = Q + RP\), where \(Q\) and \(P\) are regular expressions and \(P\) does not contain the empty string \(\epsilon\) then \(R = QP*\) is a solution for the equation.</p> <p>Applying it to \(q_2\) we get \(q_2 = ( q_1 0 ) ( 1 * )\) - this represents the language accepted by \(q_1\) followed by a 0 and then any number of 1s.</p> <p>Now substituting this on the equation for \(q_1\) we get \(q_1 = q_0 1 + ( q_1 0 ) (\ 1 * ) 0\).</p> <p>We can now apply Arden’s Theorem again: \(q_1 = ( q_0 1 ) ( 0 ( 1 * ) 0 ) *\) - and you get the language accepted by \(q_0\) followed by a 1 and then any number of repetitions starting with 0, followed by zero or more 1s and ending with 0.</p> <p>Now we can write \(q_0 = \epsilon + q_0 0 + q_0 1 ( 0 ( 1 * ) 0 ) * 1 = \epsilon + q_0 ( 0 + 1 ( 0 ( 1 * ) 0 ) * 1 )\).</p> <p>Applying Arden’s Theorem again we get:</p> \[q_0 = ( \epsilon ) ( 0 + 1 ( 0 ( 1 * ) 0 ) * 1 ) *\] <p>That can be further simplified to</p> \[q_0 = ( \epsilon ) ( 0 + 1 ( 0 ( 1 * ) 0 ) * 1 ) *\] <p>This is the final expression for \(q_0\) that describe all the strings accepted by the automata that start and end in this state.</p> <h2 id="solution-and-reflection">Solution and reflection</h2> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">multiple_of_3_regex</span> <span class="o">=</span> <span class="s">"^(0|1(01*0)*1)*$"</span><span class="p">;</span></code></pre></figure> <p>It’s fascinating how theoretical computer science principles blend into practical programming challenges. It’s a vivid reminder that beneath every line of code lies a rich tapestry of logic and mathematics, waiting to be explored and appreciated. Every challenge is not just a test of skill, but an invitation to an intellectual adventure, revealing the interconnectedness of concepts we sometimes take for granted.</p> <h2 id="further-information">Further information</h2> <p><a href="https://www.geeksforgeeks.org/ardens-theorem-in-theory-of-computation/">Arden’s theorem</a> <a href="https://www.youtube.com/watch?v=SmT1DXLl3f4">Khan Academy - DFA to Regular Expression</a></p>]]></content><author><name></name></author><category term="regex"/><category term="codewars"/><category term="regex"/><category term="dfa"/><category term="binary"/><category term="codewars"/><summary type="html"><![CDATA[the challenge was to create a regular expression capable of recognizing multiples of 3.]]></summary></entry><entry><title type="html">Not so Agile Marathon</title><link href="jjginga.github.io/blog/2024/not-so-agile-marathon/" rel="alternate" type="text/html" title="Not so Agile Marathon"/><published>2024-02-24T20:00:00+00:00</published><updated>2024-02-24T20:00:00+00:00</updated><id>jjginga.github.io/blog/2024/not-so-agile-marathon</id><content type="html" xml:base="jjginga.github.io/blog/2024/not-so-agile-marathon/"><![CDATA[<div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/medal_seville-480.webp 480w,/assets/img/medal_seville-800.webp 800w,/assets/img/medal_seville-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/medal_seville.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>In preparing for a marathon, I embarked on a long-term project that spanned several months. It’s accurate to say I engaged in a series of sprints to prepare for my marathon, both figuratively, analogous to multiple sprints in an Agile framework, and literally. My training included ‘iterations’ of high effort followed by rest, mirroring the sprint-and-pause rhythm of interval training. But in a whimsical twist of language, these bursts of speed are known as “series” in Portuguese, giving a whole new meaning to running a series of sprints before the actual Sprint.</p> <p>The objective was clear: complete the marathon within a target time, serving as my project’s final goal. The training was divided into four phases, each with its own objectives, akin to sprint goals in Agile: enhancing overall fitness, boosting speed, increasing endurance, and ultimately tapering for the marathon. These phases were further broken down into smaller increments, approximately a week long—my sprint durations—culminating in a long run each Sunday, my deliverable.</p> <p>Given that running isn’t my primary activity—I balance both work and study—the normal adjustments from learning through experience were complemented by others, tailored to fit my circumstances. Typically, my sprint planning occurred on Mondays, where I would assess the previous week’s training and establish my commitments based on my velocity and past performances. Despite my initial fitness level, the goals were met.</p> <p>A marathon is so extensive that it could be seen both as a sprint – although my pace is far from swift – and as a goal. This happens because in a 42km race, time feels dilated, when you are running 4h41 minutes feel like more than a week. So as race day neared, I conducted my final planning, electing to gi with the 4:30-hour pace group. This was a realistic commitment, in line with in the achievements of earlier project phases.</p> <p>However, once the race day arrived—our sprint began—I faced a challenge. The pace set by the 4:30 group misaligned with my natural running rhythm; it felt too slow, especially in the flat terrain of Seville, making it increasingly hard to maintain, and I started to accelerate. Despite knowing from past marathons that this strategy would lead me to failure, overconfidence and a desire to outperform my expectations—a common pitfall in both running and Agile projects—led me to put aside what I learned from previous experience. Like a team realizing early in a sprint that their approach might not deliver the sprint goal due to external factors or misestimations, yet failing to adjust accordingly.</p> <p>I decided to adapt my strategy on the fly, aiming for a 4-hour finish, exceeding my initial expectations. By the 20km mark, it was evident things weren’t going as planned, but I continued, one kilometer at a time, maintaining my pace against the odds.</p> <p>Unfortunately, this led to a significant challenge at the 30km mark, where I “hit the wall,” or as we say in Portuguese, “o homem da marreta apanhou-me”—no direct translation can encapsulate this expression, the idea is that while you are running a marathon you are being chased by someone with a giant hammer, ready to strike if they catch you. He caught with me and hit me with the hammers, like a team realizing too late that they’ve overcommitted or misjudged their capacity, resulting in burnout or unfinished work.</p> <p>I ended up finishing in 4h41 minutes. I did 30km in 3h and I basically crawled the rest of the way. If I had gone with the 4h30 group the experience wouldn’t be as painful as it was.</p> <p>Reflecting on this experience, the importance of the Agile principle of inspecting and adapting becomes clear. Just as Agile uses retrospectives to reflect on what worked, what didn’t, and how to improve, I must take this opportunity to learn from both the race and the training leading up to it. Recognizing the significance of pacing, the limits of my current capabilities, and the need for strategy adjustments based on real-time feedback are all invaluable lessons.</p> <p>For my next race—our next project or sprint cycle—I’ll approach with a focus on realistic goal setting, continuous performance adjustment, and maintaining a sustainable pace. The aim is not only to reach the finish line but to do so smiling instead of crawling.</p>]]></content><author><name></name></author><category term="agile"/><category term="agile"/><category term="marathon"/><summary type="html"><![CDATA[reflecting on this experience, the importance of the agile principle of inspecting and adapting becomes clear.]]></summary></entry></feed>