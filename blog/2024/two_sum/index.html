<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> challenge - two sum | Joel José Ginga </title> <meta name="author" content="Joel José Ginga"> <meta name="description" content="to find two numbers in an array that sum up to a given target value."> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/fav_ico.png?e688784a79be3227fd8224aa1b612326"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="jjginga.github.io/blog/2024/two_sum/"> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "challenge - two sum",
            "description": "to find two numbers in an array that sum up to a given target value.",
            "published": "February 29, 2024",
            "authors": [
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Joel</span> José Ginga </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>challenge - two sum</h1> <p>to find two numbers in an array that sum up to a given target value.</p> </d-title> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#challenge">Challenge</a> </div> <div> <a href="#initial-approach">Initial approach</a> </div> <ul> <li> <a href="#c">C++</a> </li> <li> <a href="#java">Java</a> </li> <li> <a href="#python">python</a> </li> </ul> <div> <a href="#time-efficient-with-hash-map">Time efficient with Hash Map</a> </div> <ul> <li> <a href="#c">C++</a> </li> <li> <a href="#java">Java</a> </li> <li> <a href="#python">python</a> </li> </ul> <div> <a href="#alternative-approach">Alternative approach</a> </div> <ul> <li> <a href="#c">C++</a> </li> <li> <a href="#java">Java</a> </li> <li> <a href="#python">python</a> </li> </ul> <div> <a href="#analysis-anc-conclusion">Analysis anc Conclusion</a> </div> <ul> <li> <a href="#comparison-of-approaches">Comparison of Approaches</a> </li> <li> <a href="#conclusion">Conclusion</a> </li> </ul> </nav> </d-contents> <h2 id="challenge">Challenge</h2> <p>I had never used leetcode before. In the last few years I spend some time in other similar platforms such has hackerank and codewars, but never leetcode. It crossed my path the other day in some random post on reddit where i read something like “everything starts with two sum”. So I decided to take a look. At first glance the problem <a href="https://leetcode.com/problems/two-sum/" rel="external nofollow noopener" target="_blank">Two Sum</a> seemed quite simple and reminded me of some other basic challenges I had encountered on other platforms. However, as I delved deeper, I realized there was more to this problem than met the eye</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Given an array of integers nums and an integer target, return indices of the two 
numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not 
use the same element twice.

You can return the answer in any order.
</code></pre></div></div> <p>For visualization purpose let’s take one of examples, if the input is nums = $ [ 15 , 11 , 2 , 7 ] $ and target = 9, the output should be $ [ 2 , 3 ] $ , the numbers at indices 2 and 3 (values 2 and 7, respectively) add up to the target value of 9.</p> <p>This problem is significant not only because it’s a common interview question but also because it serves as an accessible introduction to key concepts in computer science, including hashing, array manipulation, and the trade-offs between time and space complexity. Its simplicity allows for a focus on algorithmic thinking and optimization strategies without the overhead of complex data structures or algorithms. Moreover, the problem’s applicability to real-world scenarios, such as database queries or financial transactions, highlights the practical importance of efficient data processing and retrieval techniques, making it a relevant and engaging challenge for programmers at all levels.</p> <h2 id="initial-approach">Initial approach</h2> <p>In a problem like this the the straightforward approach, and I think the one that comes to most people minds is the use of brute force. That is, using a double loop to iterate through the array, comparing each pair of numbers to see if they added up to the target. This method it simple enough, but, it has a time complexity of $ O ( n^2 ) $, it is far from optimal for larger arrays. Here is this approach in C++, Java and python. This was confirmed when I submitted the code and found that it was only faster than 30% of code submitted by other users.</p> <h2 id="c">C++</h2> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> 
                <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> 
                    <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">};</span>
                        
        <span class="k">return</span> <span class="p">{};</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre></figure> <h2 id="java">Java</h2> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span>

        <span class="nf">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">;</span> <span class="n">i</span> <span class="o">++)</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]==</span><span class="n">target</span><span class="o">)</span>
                    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">};</span>
      
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure> <h2 id="python">python</h2> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range </span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="nf">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="n">target</span><span class="p">):</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="p">[]</span></code></pre></figure> <h2 id="time-efficient-with-hash-map">Time efficient with Hash Map</h2> <p>A resounding difference between leetcode and the other platforms I used before is the plethora of discussions, solutions and even videos. I always like to see how a problem can be tackled in multiple ways, each with its own trade-offs in terms of time and space complexity. So i revisited the problem, but this time armed with new insights and a hash table. The idea was to store each element’s value and its index in the array. As I iterated through the array, I checked if the complement of the current element (target - current element) was already in the hash table. If it was, I had found the two numbers.</p> <p>In a hash table the values are stored associating a specific key to corresponding values. To store and retrieve these values, an hashing function is used. This causes that the average complexity of search, insert and delete data in a hash table is of a \(O ( 1 )\) time complexity. This approach significantly reduced the time complexity to \(O ( n )\), a vast improvement over my initial brute-force method. But, unlike the brute force method that has a space complexity of \(O ( 1 )\), the space complexity is now \(O ( n )\), since in the worst case scenario we will need to store each element of the array in the hash map.</p> <h2 id="c-1">C++</h2> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//initialize an unordered_map to store the array values and their indices</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">numMap</span><span class="p">;</span>

        <span class="c1">//iterate through the array</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span>  <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="c1">//calculate the complement by subtracting the current value to the target</span>
            <span class="kt">int</span> <span class="n">complement</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="c1">//check if the element exists in the map</span>
            <span class="k">if</span><span class="p">(</span><span class="n">numMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">complement</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
                <span class="c1">//if found, return the indices of the current value and its complement</span>
                <span class="k">return</span><span class="p">{</span><span class="n">numMap</span><span class="p">[</span><span class="n">complement</span><span class="p">],</span> <span class="n">i</span><span class="p">};</span>
            <span class="c1">//store the current value and it's index in the map</span>
            <span class="n">numMap</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>   

        <span class="k">return</span> <span class="p">{};</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre></figure> <h2 id="java-1">Java</h2> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//create an HashMap to store the array values and their indices</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span>  <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        
        <span class="c1">//iterate through the array</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">;</span> <span class="n">i</span> <span class="o">++){</span>
            <span class="c1">//calculate the complement by subtracting the current value to the target</span>
            <span class="kt">int</span> <span class="n">complement</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="c1">//check if the element exists in the map</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">complement</span><span class="o">))</span>
                <span class="c1">//if found, return the indices of the current value and its complement</span>
                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">complement</span><span class="o">),</span><span class="n">i</span><span class="o">};</span>
            <span class="c1">//store the current value and it's index in the map</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure> <h2 id="python-1">python</h2> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># initialize the set to store the array values and their indices
</span>        <span class="n">nums_set</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
        
        <span class="c1"># iterate through the array
</span>        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="c1"># calculate the complement by subtracting the current value to the target
</span>            <span class="n">complement</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">num</span>
            <span class="c1">#check if the complement exists in the set
</span>            <span class="k">if</span> <span class="n">complement</span> <span class="ow">in</span> <span class="n">nums_set</span><span class="p">:</span>
                <span class="c1"># if found, return the indices of the current value and its complement
</span>                <span class="k">return</span> <span class="p">[</span><span class="n">nums</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">complement</span><span class="p">),</span> <span class="n">nums</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="c1">#store the current number in the set
</span>            <span class="n">nums_set</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">[]</span></code></pre></figure> <p>This approach parachuted me to be faster than 80% of other submissions in C++ and to the 98% faster in Java and python.</p> <h2 id="alternative-approach">Alternative approach</h2> <p>While the hash table approach significantly improves the time efficiency, it does introduce a higher space complexity of \(O ( n )\). This got me thinking if whether there’s a middle ground that could offer a better balance between time and space efficiency.</p> <p>A potential approach is to consider the two pointer technique, applicable if the array is sorted or if sorting doesn’t affect the solution’s correctness. This method involves placing one pointer at the beginning of the array and another at the end and then moving them towards each other until the target sum is found. The time complexity is then \(O ( n \log n)\) from the sorting and the space complexity is \(O ( n )\).</p> <h2 id="c-2">C++</h2> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="c1">//create vector to store pairs of numbers and their original indices</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">vector</span><span class="p">;</span>
        
        <span class="c1">//populate the vector with the pairs</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="p">));</span>

        <span class="c1">//sort the vector based on the numeric value</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">vector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
            <span class="p">[](</span><span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">){</span>
                <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
            <span class="p">});</span>
        
        <span class="c1">//initialize the pointers</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        
        
        <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">){</span>
            <span class="c1">//calculate the sum of the two pointed values</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="n">left</span><span class="p">].</span><span class="n">first</span><span class="o">+</span><span class="n">vector</span><span class="p">[</span><span class="n">right</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
            
            <span class="c1">//if the sum matches the target, we return the original indices of the two</span>
            <span class="k">if</span><span class="p">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">{</span> <span class="n">vector</span><span class="p">[</span><span class="n">left</span><span class="p">].</span><span class="n">second</span><span class="p">,</span> <span class="n">vector</span><span class="p">[</span><span class="n">right</span><span class="p">].</span><span class="n">second</span><span class="p">};</span>
            
            <span class="c1">//if the sum is less than the target, move the left pointer to the right</span>
            <span class="c1">//that is, we increase the left value</span>
            <span class="k">if</span><span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">){</span>
                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="c1">//if the sum is greater than the target, we move the right pointer to the left</span>
            <span class="n">right</span><span class="o">--</span><span class="p">;</span>
            
        <span class="p">}</span>
 
        <span class="k">return</span> <span class="p">{};</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre></figure> <h2 id="java-2">Java</h2> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//create an array with the numbers and their indices</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">numsWithIndices</span> <span class="o">=</span> <span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
                                           <span class="o">.</span><span class="na">mapToObj</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">})</span>
                                           <span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]::</span><span class="k">new</span><span class="o">);</span>
        
        <span class="c1">//sort the array based on the numeric vlaues</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">numsWithIndices</span><span class="o">,</span> <span class="nc">Comparator</span><span class="o">.</span><span class="na">comparingInt</span><span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>

        <span class="c1">//initialize the two pointers</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        

        <span class="c1">//iterate through the array using the two pointers</span>
        <span class="k">while</span><span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
            <span class="c1">//calculate the sum of the two pointed values</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">numsWithIndices</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="mi">0</span><span class="o">]+</span><span class="n">numsWithIndices</span><span class="o">[</span><span class="n">right</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            
            <span class="c1">//if the sum matches the target, we return the original indices of the two</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span><span class="o">==</span><span class="n">target</span><span class="o">)</span>
                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">numsWithIndices</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="n">numsWithIndices</span><span class="o">[</span><span class="n">right</span><span class="o">][</span><span class="mi">1</span><span class="o">]};</span>
            
            <span class="c1">//if the sum is less than the target, move the left pointer to the right</span>
            <span class="c1">//that is, we increase the left value</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">left</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="c1">//if the sum is greater than the target, we move the right pointer to the left</span>
            <span class="n">right</span><span class="o">--;</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure> <h2 id="python-2">python</h2> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># create an array of tuples of the numbers and the original indices, sorted by the number
</span>        <span class="n">numsWithIndices</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">((</span><span class="n">num</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>
        
        <span class="c1"># initialize the pointers
</span>        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        
        <span class="c1"># iterate through the array using the two pointers
</span>        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="c1"># calculate the sum of the two pointed values
</span>            <span class="nb">sum</span> <span class="o">=</span> <span class="n">numsWithIndices</span><span class="p">[</span><span class="n">left</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">numsWithIndices</span><span class="p">[</span><span class="n">right</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># if the sum matches the target, we return the original indices of the two
</span>            <span class="k">if</span> <span class="nb">sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">numsWithIndices</span><span class="p">[</span><span class="n">left</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">numsWithIndices</span><span class="p">[</span><span class="n">right</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
            
            <span class="c1">#if the sum is less than the target, move the left pointer to the right
</span>            <span class="k">if</span> <span class="nb">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            
            <span class="c1">#if the sum is greater than the target, we move the right pointer to the left
</span>            <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="p">[]</span></code></pre></figure> <h2 id="reflection">Reflection</h2> <p>The journey through solving the “Two Sum” problem on LeetCode has been enlightening. It showcased the importance of understanding both time and space complexity and how different approaches can significantly impact performance. From a brute-force method to a time-efficient hash table solution, and exploring a space-efficient two-pointer technique, each method provided valuable insights.</p> <p>The brute-force method, while straightforward, highlighted the importance of considering time complexity from the outset. The hash map solution, on the other hand, was a practical lesson in how space-time trade-offs work in algorithm design. Finally, the sorting and two-pointer technique provided a clear example of how sometimes a preliminary step (like sorting) can lead to more efficient solutions, even if it seems counterintuitive at first.</p> <h2 id="comparison-of-approaches">Comparison of Approaches</h2> <p>A comparison of these methods can offer valuable insights. Understanding the nuances of each approach allows developers to make more informed decisions when faced with similar problems.</p> <table> <thead> <tr> <th> </th> <th style="text-align: center">Time Complexity</th> <th style="text-align: center">Space Complexity</th> <th style="text-align: center">Readability</th> </tr> </thead> <tbody> <tr> <td>Brute-Force</td> <td style="text-align: center">\(O ( n^2 )\)</td> <td style="text-align: center">\(O ( 1 )\)</td> <td style="text-align: center">High</td> </tr> <tr> <td>Hash Map</td> <td style="text-align: center">\(O ( n )\)</td> <td style="text-align: center">\(O ( n )\)</td> <td style="text-align: center">Moderate</td> </tr> <tr> <td>Two-Pointer</td> <td style="text-align: center">\(O ( n \log n )\)</td> <td style="text-align: center">\(O ( n )\)</td> <td style="text-align: center">Moderate</td> </tr> </tbody> </table> <p>Choosing the right approach depends on several factors, including the size of the input data, the computational resources available, and the specific requirements of the application. By carefully considering these aspects, developers can select the most appropriate solution, optimizing for performance, readability, and resource usage as needed.</p> <p>So, Brute-force also has its advantages, it is the more readable solution and simple implementation. If we have small datasets, if the simplicity and readability are more important than efficiency concerns, or if our system has limited memory this solution may be ideal. If we have large data-sets and are in a performance-sensitive application, the reduction of the execution time from the constant-time lookups make this solution ideal. On the other hand the Two-Pointer technique is ideal for medium to large datasets where a balance between time and space efficiency is desired. This method is particularly useful when the input array can be sorted without affecting the solution’s correctness, offering a good compromise between the brute-force and hash map approaches.</p> <p>We can also analyze the performance in terms of execution time and memory usage in the leetcode platform for each programming language</p> <table> <thead> <tr> <th>Approach</th> <th>Language</th> <th>Best Time (ms)</th> <th>Best Memory (MB)</th> </tr> </thead> <tbody> <tr> <td>Brute-Force</td> <td>Java</td> <td>44</td> <td>44.6</td> </tr> <tr> <td> </td> <td>C++</td> <td>9</td> <td>14.2</td> </tr> <tr> <td> </td> <td>Python3</td> <td>1681</td> <td>17.3</td> </tr> <tr> <td>Hash Map</td> <td>Java</td> <td>2</td> <td>45.3</td> </tr> <tr> <td> </td> <td>C++</td> <td>8</td> <td>14.1</td> </tr> <tr> <td> </td> <td>Python3</td> <td>49</td> <td>17.8</td> </tr> <tr> <td>Two-Pointers</td> <td>Java</td> <td>9</td> <td>44.1</td> </tr> <tr> <td> </td> <td>C++</td> <td>3</td> <td>13.5</td> </tr> <tr> <td> </td> <td>Python3</td> <td>60</td> <td>18</td> </tr> </tbody> </table> <p>The Hash Map approach shows the best performance in Java, significantly reducing the execution time to 2 ms, which is a substantial improvement over the Brute-Force and Two-Pointers methods. This demonstrates the efficiency of hash maps in optimizing lookup operations, making it the preferred choice for large datasets where time complexity is a critical factor.</p> <p>C++ implementations consistently show low execution times across all approaches, with the Hash Map and Two-Pointers methods being particularly efficient. This underscores C++’s performance advantages, especially in memory usage, where it outperforms the other languages.</p> <p>Python, while not matching the execution speeds of Java and C++, benefits significantly from the Hash Map approach, reducing its execution time to 49 ms from the much slower brute-force implementation. This illustrates Python’s effective use of dynamic data structures like dictionaries for optimizing time complexity, albeit with a higher space complexity.</p> <p>The performance results for each approach in different programming languages also highlights the impact of language-specific optimizations and data structure implementations on algorithm efficiency. For instance, Java’s significant time reduction using hash maps can be attributed to its highly optimized HashMap class, while C++’s lower memory usage reflects the language’s close-to-hardware design, allowing for more controlled memory management. Python’s slower execution times, compared to C++ and Java, underscore the trade-offs of using a dynamically typed, interpreted language, which prioritizes development speed and ease of use over raw performance. These variations underscore the importance of choosing the right tool for the job, considering both the problem at hand and the execution environment.</p> <h2 id="conclusion">Conclusion</h2> <p>The “Two Sum” problem, in its simplicity and complexity, serves as a microcosm of the broader journey in computer science—a journey of continuous learning, problem-solving, and growth. The exploration of different solutions not only deepens our understanding of algorithmic efficiency but also equips us with a versatile toolkit for approaching future coding challenges. Recognizing when to use a brute-force method for its simplicity, a hash map for its time efficiency, or a two-pointer technique for a balanced approach can drastically improve our problem-solving strategies. These insights encourage a more nuanced consideration of trade-offs in algorithm design, preparing us to tackle a wide range of problems with informed decision-making about when and how to optimize for time, space, and code readability.</p> <p>This exploration has not only enhanced my problem-solving toolkit but also sharpened my decision-making skills, teaching me to weigh the trade-offs between different approaches based on the problem’s requirements. As I move forward, these insights will be invaluable, guiding me through future challenges with a deeper understanding of when and how to apply each method effectively.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> <div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"jjginga/jjginga.github.io","data-repo-id":"R_kgDOLWrGQw","data-category":"Comments","data-category-id":"","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Joel José Ginga. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>