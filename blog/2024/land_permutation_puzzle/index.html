<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> land permutation puzzle | Joel José Ginga </title> <meta name="author" content="Joel José Ginga"> <meta name="description" content="tackling the land permutation puzzle - a quest for minimized borders"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/fav_ico.png?e688784a79be3227fd8224aa1b612326"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="jjginga.com/blog/2024/land_permutation_puzzle/"> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "land permutation puzzle",
            "description": "tackling the land permutation puzzle - a quest for minimized borders",
            "published": "March 23, 2024",
            "authors": [
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Joel</span> José Ginga </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>land permutation puzzle</h1> <p>tackling the land permutation puzzle - a quest for minimized borders</p> </d-title> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#the-land-permutation-puzzle">The Land Permutation Puzzle</a> </div> <ul> <li> <a href="#problem-definition">Problem Definition</a> </li> </ul> <div> <a href="#navigating-solutions-bfs-dfs-and-iddfs-explained">Navigating Solutions - BFS, DFS, and IDDFS Explained</a> </div> <ul> <li> <a href="#breadth-first-search-bfs">Breadth-First Search (BFS)</a> </li> <li> <a href="#depth-first-search-dfs">Depth-First Search (DFS)</a> </li> <li> <a href="#iterative-deepening-depth-first-search-iddfs">Iterative Deepening Depth-First Search (IDDFS)</a> </li> <li> <a href="#comparassion">Comparassion</a> </li> </ul> <div> <a href="#implementation">Implementation</a> </div> <ul> <li> <a href="#problem-modeling">Problem Modeling</a> </li> <li> <a href="#algorithms">Algorithms</a> </li> </ul> <div> <a href="#results">Results</a> </div> <div> <a href="#discussion">Discussion</a> </div> <div> <a href="#further-information">Further Information</a> </div> </nav> </d-contents> <h2 id="the-land-permutation-puzzle">The Land Permutation Puzzle</h2> <p>In the intricate tapestry of computational challenges, the “Land Permutation Problem” stands out. It’s a deceivingly straightforward puzzle derived from the artificial intelligence course in computer science degree, involving a matrix of lands owned by various proprietors. The goal is to minimize the number of different owners’ borders. This territorial jigsaw requires both insightful analysis and strategic algorithmic application. To understand the intricacies and rules of this puzzle, explore the problem statement on <a href="https://github.com/jjginga/LandPermutationProblem" rel="external nofollow noopener" target="_blank">GitHub</a>.</p> <p><em>The problem as described in the README of the repository is a practical component of my studies.</em></p> <h4 id="problem-definition">Problem Definition</h4> <p>The task involves a given matrix of NxM houses representing a map of lands of equal dimension with K owners. The goal is to reduce the number of borders between lands of different owners to a number equal to or less than W. A border exists between two houses with different owners. Owners can be represented by colors, letters, or numbers, with numbers being used in our program.</p> <table> <thead> <tr> <th>Component</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><strong>Objective</strong></td> <td>test(s) ≤ W</td> </tr> <tr> <td><strong>Initial State</strong></td> <td>s0 ∈ S</td> </tr> <tr> <td><strong>Possible Actions</strong></td> <td>A = {(n, m, n’, m’) | lands (n,m) and (n’,m’) are adjacent}</td> </tr> <tr> <td><strong>Transition Model</strong></td> <td>exe((s, (n, m, n’, m’))) = s’ where s’ is the matrix resulting from exchanging the owner of (n,m) and (n’, m’).</td> </tr> <tr> <td><strong>Cost</strong></td> <td>-</td> </tr> <tr> <td><strong>Successors</strong></td> <td>succ(s) = {s’ | ∃a ∈ A, s’ = exe(s, a)}</td> </tr> <tr> <td><strong>Solution</strong></td> <td>sf ∈ S | test(sf)</td> </tr> <tr> <td><strong>Constraints</strong></td> <td>test(s’) ≤ test(s)</td> </tr> </tbody> </table> <p>This table succinctly encapsulates the problem’s components, providing a clear framework for the “Land Permutation Problem.” The constraints ensure that the number of borders in a successor state must not exceed that of the current state, guiding the search towards the objective.</p> <h2 id="navigating-solutions-bfs-dfs-and-iddfs-explained">Navigating Solutions: BFS, DFS, and IDDFS Explained</h2> <p>This problem — minimizing the number of borders between lands with different owners — can be modeled as a graph traversal challenge. Each configuration of the land map, representing territories and their borders, can be considered a node (or vertex) in a graph. The initial state is the root node, and each possible action (e.g., swapping two adjacent territories to potentially reduce borders) leads to a successor state, which is a child node in the graph.</p> <p>So, to solve this enigmatic puzzle we can use three classic algorithms, each with its own strengths and peculiarities. <strong>Breadth-First Search (BFS)</strong> is like casting a wide net, exploring all neighboring nodes at the current depth before diving deeper. It’s methodical, ensuring no stone is left unturned, but its memory consumption can quickly become a concern as the breadth of exploration expands.</p> <p>In contrast, <strong>Depth-First Search (DFS)</strong> opts for a more tunnel-vision approach, diving deep into the problem space one path at a time. Its memory footprint is lighter, making it nimble and efficient in certain mazes of complexity. However, its laser focus can sometimes be a drawback, as it might miss broader solutions found at shallower depths.</p> <p><strong>Iterative Deepening Depth-First Search (IDDFS)</strong>, then, marries the thoroughness of BFS with the memory efficiency of DFS. By incrementally deepening the search depth, IDDFS systematically covers the search space, ensuring completeness without the heavy memory burden associated with BFS.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/search_algorithms-480.webp 480w,/assets/img/search_algorithms-800.webp 800w,/assets/img/search_algorithms-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/search_algorithms.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <h2 id="breadth-first-search-bfs">Breadth-First Search (BFS)</h2> <p>Breadth-First Search (BFS) systematically covers a graph by visiting adjacent vertices in successive levels.</p> <h4 id="how-bfs-works">How BFS Works:</h4> <ol> <li> <strong>Initialization</strong>: BFS begins with the root node (initial state) and explores all its neighbors (successor states).</li> <li> <strong>Queue Management</strong>: It employs a queue to keep track of the frontier—the set of all nodes visible but not yet explored.</li> <li> <strong>Uniform Exploration</strong>: At each step, BFS dequeues the next node from the frontier, examines it for a solution, and enqueues all its unvisited neighbors.</li> <li> <strong>Memory Consideration</strong>: The major downside of BFS in complex puzzles like land permutation is its memory usage, which grows exponentially with the number of levels explored.</li> </ol> <h2 id="depth-first-search-dfs">Depth-First Search (DFS)</h2> <p>Depth-First Search delves into a graph, extending as far along each path as possible before backtracking to explore other branches.</p> <h4 id="how-dfs-operates">How DFS Operates:</h4> <ol> <li> <strong>Initialization</strong>: Starting at the root, DFS pushes the initial state onto a stack.</li> <li> <strong>Stack Utilization</strong>: It utilizes a stack to manage the nodes currently being explored.</li> <li> <strong>Depth Exploration</strong>: DFS continuously explores down one branch until it hits a dead end, then backtracks to explore other branches.</li> <li> <strong>Memory Efficiency</strong>: Its stack-based approach limits memory usage to the maximum depth of the search space, unlike BFS’s breadth-based memory expansion.</li> <li> <strong>Solution Depth</strong>: While efficient, DFS is not guaranteed to find the shortest solution in terms of moves or transformations.</li> </ol> <h2 id="iterative-deepening-depth-first-search-iddfs">Iterative Deepening Depth-First Search (IDDFS)</h2> <p>Iterative Deepening Depth First Search (IDDFS) progressively deepens the reach of Depth-First Search, applying a breadth-like approach to depth-limited searches.</p> <h4 id="how-iddfs-functions">How IDDFS Functions:</h4> <ol> <li> <strong>Depth Iteration</strong>: Starting with a shallow depth limit, IDDFS performs a DFS within this limit. If no solution is found, the limit is increased, and the search is repeated.</li> <li> <strong>Balance of Efficiency</strong>: This approach ensures that the memory advantages of DFS are maintained while achieving the breadth of coverage that BFS offers.</li> <li> <strong>Optimality</strong>: Like BFS, IDDFS will find the optimal solution in terms of the shortest path to the goal.</li> <li> <strong>Revisitation</strong>: Each iteration revisits nodes from previous depths, which is the trade-off for its balance between BFS and DFS advantages.</li> </ol> <h2 id="comparassion">Comparassion</h2> <table> <thead> <tr> <th>Algorithm</th> <th>Time Complexity</th> <th>Space Complexity</th> <th>Characteristics</th> </tr> </thead> <tbody> <tr> <td><strong>BFS</strong></td> <td>O( \(b^d\) )</td> <td>O( \(b^d\) )</td> <td>Complete and optimal; explores all neighbors at a given depth before moving deeper. High memory use due to storage of all nodes at the current level.</td> </tr> <tr> <td><strong>DFS</strong></td> <td>O( \(b^m\) )</td> <td>O(bm)</td> <td>Not necessarily complete or optimal; explores as far as possible along a branch before backtracking. Lower memory use as it stores only a single path from the root to a leaf node, along with remaining unexplored siblings for each node on the path.</td> </tr> <tr> <td><strong>IDDFS</strong></td> <td>O( \(b^d\) )</td> <td>O(bd)</td> <td>Combines the advantages of BFS and DFS. Complete and optimal like BFS, but with the memory efficiency of DFS. Iteratively deepens, effectively performing a DFS to a specific depth, then increasing this limit iteratively.</td> </tr> </tbody> </table> <p><strong>Key:</strong></p> <ul> <li> <strong>b</strong>: branching factor (the average number of child nodes per node)</li> <li> <strong>d</strong>: depth of the shallowest solution</li> <li> <strong>m</strong>: maximum depth of the state space (potentially infinite)</li> </ul> <p>This table elucidates the stark contrasts between these search algorithms, particularly in terms of their space and time efficiency. BFS and IDDFS share the same time complexity, reflecting their completeness and ability to find the optimal solution. However, the space complexity of IDDFS is dramatically lower, akin to DFS, making it an appealing choice for problems where space is a limiting factor and completeness is required.</p> <p>This table elucidates the stark contrasts between these search algorithms, particularly in terms of their space and time efficiency. BFS and IDDFS share the same time complexity, reflecting their completeness and ability to find the optimal solution. However, the space complexity of IDDFS is dramatically lower, akin to DFS, making it an appealing choice for problems where space is a limiting factor and completeness is required.</p> <h2 id="implementation">Implementation</h2> <p>To solve this problem I splitted it into two parts:</p> <ul> <li>a “framework” designed to solve state space search problems where the objective is to minimize some goal that can be expressed numerically and can be reused for other problems. For that purpose we implemented a variety of search techniques including Breadth-First Search (BFS), Depth-First Search (DFS), and Iterative Deepening Depth-First Search (IDDFS), each encapsulated within its own class and implementing a common abstract search technique interface.</li> <li>a class that defines the state space of the Land Permutation problem and can be coupled with the “framework”.</li> </ul> <h4 id="problem-modeling">Problem Modeling</h4> <p>The <strong>LandMap</strong> class represents the state space, defining the layout of lands and borders that need to be manipulated. It includes methods for state evaluation (border count), generating successors, and performing swap operations which are fundamental actions of the search algorithms. These actions ensure that only valid moves towards the objective are considered, preventing an increase in the number of borders.</p> <p>The <strong>countBorders</strong> function is designed to iterate through each cell of the land map matrix and check for borders, where a border is defined as a side where adjacent cells have different values (representing different owners). This operation is O(N) where N is the number of cells in the matrix because it performs a constant amount of work for each cell: one comparison with its right neighbor and one with its bottom neighbor (except for cells on the rightmost and bottom edges, which have no neighbors in that direction). Without two loops or nested loops per cell that would increase the time complexity.</p> <p>To <strong>generate the successor states</strong> the border count is tested before creating a new object to ensure the move is beneficial towards achieving the goal of minimizing borders, and this pre-validation step is crucial for maintaining the efficiency of the search algorithms. Each potential swap of adjacent territories in the land map is a candidate move that might lead to a new state; however, not all moves lead to a desirable outcome. By assessing the impact of a swap on the number of borders before actually instantiating a new LandMap object, the algorithm effectively filters out successor states that would not contribute to the solution. This pre-emptive check prevents the unnecessary creation and storage of state objects that do not bring the search any closer to the goal, which would otherwise waste computational resources and potentially slow down the search process due to increased memory usage and garbage collection overhead.</p> <h4 id="algorithms">Algorithms</h4> <p>In the implementation of the search algorithms we went for a clean and modular approach, going for an algorithm design that are applicable to a broad range of problems beyond just the land permutation challenge. The Breadth-First Search (BFS) class utilizes a <strong>Queue</strong> data structure to ensure a level-order traversal. The Depth-First Search (DFS) class employs a <strong>Stack</strong> to dive deep into the search space, backtracking when necessary. This approach is typical for DFS’s deep exploration strategy, which is both memory-efficient and adept at handling problems with vast search spaces.</p> <p>Iterative Deepening Depth-First Search (IDDFS) marries the strengths of both BFS and DFS by combining the memory efficiency of DFS with the completeness of BFS. IDDFS systematically increases the depth limit, essentially performing a DFS to the current limit, then restarting with a deeper limit, allowing for a progressive exploration that is both thorough and space-conscious. Each of these classes is architected to encapsulate the search logic within its own module, using polymorphism through an interface that defines the structure of a search technique, making the algorithms interchangeable and reusable.</p> <h2 id="results">Results</h2> <p>The following table presents the outcomes of applying different search algorithms to the several instances of the land permutation problem with the w1 goals. Each entry outlines the depth reached, the number of states generated, and the execution time recorded for the corresponding search technique and instance. It’s important to note that an execution time marked as “&gt;60s” indicates that the algorithm did not find a solution within the 60-second time limit. For these instances, the depth and generated states reflect the search progress made up to the point of timeout. These metrics are crucial for understanding the performance and efficiency of each algorithm under the constraints of time-limited execution.</p> <table> <thead> <tr> <th>Instance</th> <th>Algorithm</th> <th>Depth</th> <th>Generated States</th> <th>Execution Time</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>Breath First Search</td> <td>3</td> <td>16</td> <td>0.0045 s</td> </tr> <tr> <td>1</td> <td>Depth-First Search</td> <td>3</td> <td>10</td> <td>0.0008 s</td> </tr> <tr> <td>1</td> <td>Iterative Deep-First Search</td> <td>3</td> <td>40</td> <td>0.0024 s</td> </tr> <tr> <td>2</td> <td>Breath First Search</td> <td>2</td> <td>9</td> <td>0.0002 s</td> </tr> <tr> <td>2</td> <td>Depth-First Search</td> <td>2</td> <td>5</td> <td>0.0001 s</td> </tr> <tr> <td>2</td> <td>Iterative Deep-First Search</td> <td>2</td> <td>15</td> <td>0.0004 s</td> </tr> <tr> <td>3</td> <td>Breath First Search</td> <td>3</td> <td>5298084</td> <td>&gt;60s</td> </tr> <tr> <td>3</td> <td>Depth-First Search</td> <td>159</td> <td>7788</td> <td>0.0065 s</td> </tr> <tr> <td>3</td> <td>Iterative Deep-First Search</td> <td>3</td> <td>5364301</td> <td>&gt;60s</td> </tr> <tr> <td>4</td> <td>Breath First Search</td> <td>4</td> <td>968</td> <td>0.0007 s</td> </tr> <tr> <td>4</td> <td>Depth-First Search</td> <td>10</td> <td>34</td> <td>0.0001 s</td> </tr> <tr> <td>4</td> <td>Iterative Deep-First Search</td> <td>4</td> <td>1819</td> <td>0.0013 s</td> </tr> <tr> <td>5</td> <td>Breath First Search</td> <td>6</td> <td>146233</td> <td>0.2841 s</td> </tr> <tr> <td>5</td> <td>Depth-First Search</td> <td>18</td> <td>174</td> <td>0.0002 s</td> </tr> <tr> <td>5</td> <td>Iterative Deep-First Search</td> <td>6</td> <td>352495</td> <td>0.7041 s</td> </tr> <tr> <td>6</td> <td>Breath First Search</td> <td>9</td> <td>14146290</td> <td>&gt;60s</td> </tr> <tr> <td>6</td> <td>Depth-First Search</td> <td>77</td> <td>679</td> <td>0.0012 s</td> </tr> <tr> <td>6</td> <td>Iterative Deep-First Search</td> <td>7</td> <td>2336663</td> <td>&gt;60s</td> </tr> <tr> <td>7</td> <td>Breath First Search</td> <td>3</td> <td>609063</td> <td>&gt;60s</td> </tr> <tr> <td>7</td> <td>Depth-First Search</td> <td>216</td> <td>5183</td> <td>0.0059 s</td> </tr> <tr> <td>7</td> <td>Iterative Deep-First Search</td> <td>4</td> <td>8387805</td> <td>&gt;60s</td> </tr> </tbody> </table> <h2 id="discussion">Discussion</h2> <p>The execution of search algorithms on the land permutation problem has demonstrated varied outcomes, which reveal the strengths and weaknesses inherent in each method. The Breath First Search (BFS), noted for its exhaustive level-by-level exploration, has proven effective in shallower instances where the breadth of potential states remains manageable. However, its performance notably diminishes as the complexity of the state space increases, often resulting in timeouts. This indicates that while BFS is thorough, its resource consumption makes it less viable for problems with expansive search trees.</p> <p>Depth-First Search (DFS), on the other hand, showcased its ability to reach deeper into the search space with a significantly lower number of generated states, emphasizing its depth-focused approach. Its memory efficiency shines in instances where the solution lies far from the root, but this comes with the trade-off of potentially overlooking nearer solutions due to its path-focused traversal. The variation in depth and generated states between DFS and BFS highlight the impact of the algorithms’ differing exploration strategies.</p> <p>Iterative Deepening Depth-First Search (IDDFS) strikes a balance between the two, ensuring completeness while retaining memory efficiency. Although IDDFS also faced timeouts in more complex instances, it consistently covered more ground, as indicated by the greater depth reached before the time cap. The iterative nature of IDDFS allows it to comb through the state space methodically, which is particularly beneficial when the solution’s depth is unknown, making it a robust choice for a wide range of scenarios.</p> <p>The results table succinctly captures the essence of these algorithms’ performances and provides a clear comparison that aids in selecting the appropriate approach for different instances of the problem. The trade-offs between time complexity, space complexity, and solution optimality become apparent, informing the decision-making process for algorithm selection in problem-solving.</p> <h2 id="further-information">Further information</h2> <p><a href="https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/" rel="external nofollow noopener" target="_blank">Geeks for Geeks - BFS</a></p> <p><a href="https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/" rel="external nofollow noopener" target="_blank">Geeks for Geeks - DFS</a></p> <p><a href="https://www.geeksforgeeks.org/iterative-deepening-searchids-iterative-deepening-depth-first-searchiddfs/" rel="external nofollow noopener" target="_blank">Geeks for Geeks - IDDFS</a></p> <p>Russell, S., &amp; Norvig, P. (2001). <em>Artificial Intelligence: A Modern Approach (3rd ed)</em>. <a href="https://aima.cs.berkeley.edu/" rel="external nofollow noopener" target="_blank">AIMA</a></p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> <div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"jjginga/jjginga.github.io","data-repo-id":"R_kgDOLWrGQw","data-category":"Comments","data-category-id":"","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Joel José Ginga. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>